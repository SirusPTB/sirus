<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LVR-1</title>
    <link rel="manifest" href="manifest.json">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="LVR-1">
    <link rel="apple-touch-icon" href="icons/icon-192x192.png">
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <meta name="mobile-web-app-capable" content="yes">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        @font-face {
            font-family: 'DSEG7Classic';
            src: url('DSEG7Classic-Bold.woff2') format('woff2'),
                url('DSEG7Classic-Bold.woff') format('woff'),
                url('DSEG7Classic-Bold.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }

        html,
        body {
            overflow: hidden;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

        body::-webkit-scrollbar {
            display: none;
        }

        body {
            font-family: Arial, sans-serif;
            background: #000;
            color: #fff;
        }

        .container {
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            position: relative;
            display: flex;
            flex-direction: column;
            max-width: 98vw;
            margin: 0 auto;
        }

        @media (max-width: 1024px) {
            .container {
                max-width: 100vw;
            }
        }

        .page {
            display: none;
            flex-direction: column;
            flex: 1;
            padding: 1.5rem;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

        .page::-webkit-scrollbar {
            width: 0;
            height: 0;
            display: none;
        }

        .page.active {
            display: flex;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
            gap: 1rem;
        }

        h2,
        h3 {
            font-size: 1.8rem;
        }

        .btn {
            background: #444;
            border: none;
            color: #fff;
            padding: 0.5rem 0.8rem;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            min-height: 40px;
            min-width: 40px;
        }

        .btn:hover {
            background: #555;
        }

        .btn-primary {
            background: #2563eb;
        }

        .btn-primary:hover {
            background: #1d4ed8;
        }

        .btn-success {
            background: #16a34a;
        }

        .btn-danger {
            background: #dc2626;
        }

        .btn-group {
            display: flex;
            align-items: center;
            gap: .8rem;
            flex-wrap: wrap;
        }

        .ble-indicator {
            font-size: 1.8rem;
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            transition: color 0.3s ease;
        }

        .ble-indicator.disconnected {
            color: #666;
        }

        .ble-indicator.connected {
            color: #0051ff;
        }

        .status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        @media (max-width: 600px) {
            .status-grid {
                grid-template-columns: repeat(auto-fit, minmax(90px, 1fr));
                gap: 0.5rem;
            }
        }

        .status-card {
            background: #1a1a1a;
            padding: 1.2rem;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 0.4rem;
            border: 2px solid #333;
            font-size: 1.1rem;
            text-align: center;
        }

        .status-card.ready {
            border-color: #16a34a;
            background: #0f2f1f;
        }

        .status-card.heating {
            border-color: #333;
            background: #1a1a1a;
        }

        .status-card {
            position: relative;
            /* required for absolute label positioning */
        }

        /* LABELS: Brew / Steam / Group */
        .status-label {
            position: absolute;
            top: 8px;
            left: 10px;
            font-size: 1.00rem;
            font-family: monospace;
            font-weight: 300;
            color: #9a9a9a;
            letter-spacing: 0.8px;
            text-transform: uppercase;
            transition: color 0.3s ease;
        }

        /* Keep temp values centered as-is */
        .status-temp {
            font-size: clamp(1.8rem, 4vw, 2.6rem);
            font-weight: 300;
            line-height: 1;
            display: flex;
            align-items: flex-start;
            gap: 0.15em;
        }

        /* Numeric value */
        .temp-value {
            font-family: 'DSEG7Classic', monospace;
            line-height: 1;
            color: #fff;
            transition: color 0.3s ease;
        }

        /* Unit label */
        .temp-unit {
            font-size: 0.5em;
            opacity: 0.8;
            margin-top: 0.15em;
            color: #9a9a9a;
            transition: color 0.3s ease;
        }

        .central-panel {
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 3rem;
        }

        .left-readings,
        .shot-timer-section {
            background: #1a1a1a;
            border: 2px solid #444;
            border-radius: 16px;
            padding: 2rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            flex: 1;
            position: relative;
        }

        .left-readings {
            display: flex;
            flex-direction: column;
            gap: 2rem;
            flex: 1;
        }

        .reading-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .reading-row {
            display: flex;
            align-items: baseline;
            gap: 0.5rem;
        }

        .reading-value {
            font-size: clamp(1rem, 7vw, 3.3rem);
            font-family: monospace;
            color: #283a8d;
        }

        .reading-unit {
            font-size: clamp(1.5rem, 6vw, 2.5rem);
            color: #283a8d;
            font-family: monospace;
        }

        .left-readings,
        .shot-timer-section {
            background: #1a1a1a;
            border: 2px solid #444;
            border-radius: 16px;
            padding: 2rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            flex: 1;
        }

        .shot-time {
            font-size: clamp(2rem, 9vw, 4.2rem);
            font-family: 'DSEG7Classic', monospace;
            line-height: 1;
            transition: color 0.3s ease;
        }

        .container.ble-disconnected .temp-value {
            color: #666 !important;
        }

        .container.ble-disconnected .temp-unit {
            color: #777 !important;
        }

        .container.ble-disconnected .status-label {
            color: #777 !important;
        }

        .container.ble-disconnected #shotTime {
            color: #666 !important;
        }

        .shot-time.running {
            color: #fff;
        }

        .shot-time.stopped {
            color: #666;
        }

        .graph-container {
            background: #1a1a1a;
            border-radius: 12px;
            padding: 1.2rem;
            cursor: pointer;
            flex: 1;
            display: flex;
            flex-direction: column;
            transition: opacity 0.3s;
            position: relative;
        }

        canvas {
            width: 100% !important;
            height: auto !important;
            flex: 1;
        }

        .graph-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            margin-top: .8rem;
            justify-content: center;
            font-size: .9rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: .5rem;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }

        .graph-tooltip {
            position: absolute;
            background: #333;
            color: #fff;
            padding: 10px;
            border-radius: 8px;
            pointer-events: none;
            font: 14px monospace;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.6);
            z-index: 10;
            display: none;
            min-width: 120px;
        }

        .brightness-control {
            background: #1a1a1a;
            padding: 1.5rem;
            border-radius: 12px;
            margin-top: 2rem;
            text-align: center;
        }

        .brightness-control label {
            display: block;
            font-size: 1.4rem;
            margin-bottom: 1rem;
            color: #ccc;
        }

        .brightness-slider {
            width: 100%;
            max-width: 400px;
            height: 10px;
            border-radius: 5px;
            background: #333;
            outline: none;
            -webkit-appearance: none;
        }

        .brightness-slider::-webkit-slider-thumb {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #2563eb;
            cursor: pointer;
        }

        .brightness-slider::-moz-range-thumb {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #2563eb;
            cursor: pointer;
            border: none;
        }

        .settings-row {
            background: #1a1a1a;
            padding: 1.5rem;
            border-radius: 12px;
            margin-bottom: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
        }

        @media (max-width: 600px) {
            .settings-row {
                flex-direction: column;
                align-items: stretch;
            }

            .settings-controls {
                display: flex;
                justify-content: space-around;
            }
        }

        .settings-label {
            font-size: 1.6rem;
        }

        .settings-value {
            font-size: 2rem;
            font-family: monospace;
            color: #06b6d4;
        }

        .btn-adjust {
            width: 60px;
            height: 60px;
            font-size: 2rem;
            font-weight: bold;
        }

        .unit-toggle-group {
            display: flex;
            justify-content: center;
            gap: 1.5rem;
            margin: 2rem 0;
            flex-wrap: wrap;
        }

        .unit-toggle-btn {
            min-width: 120px;
            font-size: 1.4rem;
            padding: 1rem 2rem;
        }

        .pid-zone {
            background: #1a1a1a;
            padding: 1.5rem;
            border-radius: 12px;
            margin-bottom: 1.5rem;
        }

        .pid-grid {
            display: grid;
            grid-template-columns: auto 1fr 1fr;
            gap: 1.2rem;
            align-items: center;
        }

        .pid-header {
            text-align: center;
            font-weight: bold;
            font-size: 1.4rem;
            padding: 0.5rem 0;
        }

        .pid-header.aggressive {
            color: #fb923c;
            grid-column: 2;
        }

        .pid-header.conservative {
            color: #06b6d4;
            grid-column: 3;
        }

        .pid-label {
            text-align: right;
            font-weight: bold;
        }

        .pid-cell {
            display: flex;
            justify-content: center;
            gap: 0.8rem;
        }

        .pid-input {
            width: 90px;
            text-align: right;
            font-family: monospace;
            font-size: inherit;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 4px;
            color: #fff;
            padding: 4px 6px;
            overflow: hidden;
        }

        .pid-input:focus {
            outline: none;
            border-color: #2563eb;
            background: #333;
        }

        .pid-input::-webkit-inner-spin-button,
        .pid-input::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .pid-input {
            -moz-appearance: textfield;
        }

        .btn-pid {
            width: 40px;
            height: 30px;
            font-size: 18px;
        }

        .full-graph {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .axis-controls {
            margin: 1rem 0;
            padding: 1rem;
            background: #1a1a1a;
            border-radius: 12px;
        }

        .axis-controls .settings-row {
            justify-content: center;
            background: transparent;
            padding: 0.3rem 0;
            margin-bottom: 0.3rem;
        }

        .axis-controls .settings-label {
            font-size: 1.3rem;
        }

        .axis-controls input[type="number"] {
            width: 70px;
            padding: 0.4rem;
            font-size: 1rem;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 4px;
            color: #fff;
            text-align: center;
        }

        .axis-controls strong {
            font-size: 1.3rem;
        }

        .pressure-display {
            font-size: clamp(2rem, 9vw, 4.2rem);
        }

        #mainPage .graph-container.nav-graph {
            flex: none;
            height: 90vh;
            min-height: 140px;
            max-height: 240px;
        }

        #mainPage #miniGraph {
            height: 90% !important;
        }

        .nav-settings {
            font-size: 1.9rem;
            line-height: 1;
            padding: 0.6rem 0.8rem;
            background: #000;
        }

        .nav-settings:hover {
            background: #111;
        }

        .pressure-display {
            font-size: clamp(2rem, 9vw, 4.2rem);
            align-items: baseline;
            /* ‚Üê Aligns text baselines (unit sits on bottom line of large number) */
            gap: 0.1em;
            /* ‚Üê Slightly tighter gap for baseline alignment */
        }

        /* New dedicated class for pressure unit */
        .pressure-unit {
            font-size: 0.5em;
            /* same as temp-unit */
            opacity: 0.8;
            /* same as temp-unit */
            color: #9a9a9a;
            /* same as temp-unit */
            /* no margin-top ‚Üí stays bottom-aligned via baseline */
        }
    </style>
</head>

<body>
    <button id="installButton"
        style="position:fixed; bottom:20px; right:20px; z-index:100; background:#2563eb; color:#fff; padding:12px 20px; border-radius:50px; border:none; box-shadow:0 4px 12px rgba(0,0,0,0.3); font-size:16px;"
        onclick="triggerInstall()">
        Install App
    </button>

    <div class="container">
        <div class="page active" id="mainPage">
            <div class="header">
                <h2>LVR-1</h2>
                <div class="btn-group">
                    <button class="btn btn-primary ble-connect-btn" onclick="toggleBLE()">Connect LVR-1</button>
                    <div class="ble-indicator disconnected" title="Bluetooth Status">
                        <svg width="28" height="28" viewBox="0 0 24 24" fill="currentColor">
                            <path
                                d="M17.71 7.71L12 2h-1v7.59L6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 11 14.41V22h1l5.71-5.71-4.3-4.29 4.3-4.29zM13 5.83l1.88 1.88L13 9.59V5.83zm1.88 10.46L13 18.17v-3.76l1.88 1.88z" />
                        </svg>
                    </div>
                    <button class="btn nav-settings" onclick="showPage('settings')">‚ãÆ</button>
                </div>
            </div>

            <div class="status-grid">
                <div class="status-card" id="brewStatus">
                    <div class="status-temp">
                        <span class="temp-value" id="brewTempValue">0.0</span>
                        <span class="temp-unit" id="brewTempUnit">¬∞C</span>
                    </div>
                    <div class="status-label">Brew</div>
                </div>

                <div class="status-card" id="groupStatus">
                    <div class="status-temp">
                        <span class="temp-value" id="groupTempValue">0.0</span>
                        <span class="temp-unit" id="groupTempUnit">¬∞C</span>
                    </div>
                    <div class="status-label">Group</div>
                </div>

                <div class="status-card" id="steamStatus">
                    <div class="status-temp">
                        <span class="temp-value" id="steamTempValue">0.0</span>
                        <span class="temp-unit" id="steamTempUnit">¬∞C</span>
                    </div>
                    <div class="status-label">Steam</div>
                </div>
            </div>

            <div class="central-panel">
                <div class="left-readings">
                    <div class="status-label">Pressure</div>
                    <div class="reading-item">
                        <!-- Updated to use dedicated pressure-unit class and baseline alignment -->
                        <div class="status-temp pressure-display">
                            <span class="temp-value" id="pressureDisplay">0.0</span>
                            <span class="pressure-unit" id="pressureUnit">bar</span>
                        </div>
                    </div>
                </div>

                <div class="shot-timer-section">
                    <div class="status-label">Shot</div>
                    <div class="shot-time stopped" id="shotTime">00</div>
                </div>
            </div>

            <div class="graph-container nav-graph" onclick="showPage('graph')">
                <canvas id="miniGraph"></canvas>
                <div class="graph-legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #f00;"></div>
                        <span>Brew Temp</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #00f;"></div>
                        <span>Group Pressure</span>
                    </div>
                </div>
                <div class="graph-tooltip"></div>
            </div>

            <div style="flex: 0.3;"></div>
        </div>

        <div class="page" id="settingsPage">
            <div class="header">
                <h2>Settings</h2>
                <div class="btn-group">
                    <div class="ble-indicator disconnected" title="Bluetooth Status">
                        <svg width="28" height="28" viewBox="0 0 24 24" fill="currentColor">
                            <path
                                d="M17.71 7.71L12 2h-1v7.59L6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 11 14.41V22h1l5.71-5.71-4.3-4.29 4.3-4.29zM13 5.83l1.88 1.88L13 9.59V5.83zm1.88 10.46L13 18.17v-3.76l1.88 1.88z" />
                        </svg>
                    </div>
                    <button class="btn" onclick="showPage('main')">‚Üê Back</button>
                </div>
            </div>

            <div class="settings-row">
                <div class="settings-label">Brew:</div>
                <div class="settings-controls">
                    <div class="settings-value" id="brewSetpointDisplay">93.0 ¬∞C</div>
                    <button class="btn btn-danger btn-adjust" onclick="adjustSetpoint('brew', -0.1)">‚àí</button>
                    <button class="btn btn-success btn-adjust" onclick="adjustSetpoint('brew', 0.1)">+</button>
                </div>
            </div>

            <div class="settings-row">
                <div class="settings-label">Steam:</div>
                <div class="settings-controls">
                    <div class="settings-value" id="steamSetpointDisplay">125.0 ¬∞C</div>
                    <button class="btn btn-danger btn-adjust" onclick="adjustSetpoint('steam', -0.1)">‚àí</button>
                    <button class="btn btn-success btn-adjust" onclick="adjustSetpoint('steam', 0.1)">+</button>
                </div>
            </div>

            <div class="settings-row">
                <div class="settings-label">Group:</div>
                <div class="settings-controls">
                    <div class="settings-value" id="groupSetpointDisplay">92.0 ¬∞C</div>
                    <button class="btn btn-danger btn-adjust" onclick="adjustSetpoint('group', -0.1)">‚àí</button>
                    <button class="btn btn-success btn-adjust" onclick="adjustSetpoint('group', 0.1)">+</button>
                </div>
            </div>

            <div class="unit-toggle-group">
                <button class="btn unit-toggle-btn" id="tempUnitBtn" onclick="toggleTempUnit()">¬∞C</button>
                <button class="btn unit-toggle-btn" id="pressureUnitBtn" onclick="togglePressureUnit()">bar</button>
            </div>

            <div class="brightness-control">
                <label for="brightnessSlider">Display Brightness</label>
                <input type="range" class="brightness-slider" id="brightnessSlider" min="5" max="255" value="200"
                    oninput="updateBrightness(this.value)">
            </div>

            <div style="display: flex; gap: 1rem; margin-top: 2rem;">
                <button class="btn btn-primary" style="flex: 1; padding: 1.5rem; font-size: 1.2rem;"
                    onclick="showPage('pid')">PID Settings</button>
                <button class="btn btn-primary" style="flex: 1; padding: 1.5rem; font-size: 1.2rem;"
                    onclick="showPage('graph')">üìà Full Graph</button>
            </div>
        </div>

        <div class="page" id="graphPage">
            <div class="header">
                <div class="btn-group">
                    <div class="ble-indicator disconnected" title="Bluetooth Status">
                        <svg width="28" height="28" viewBox="0 0 24 24" fill="currentColor">
                            <path
                                d="M17.71 7.71L12 2h-1v7.59L6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 11 14.41V22h1l5.71-5.71-4.3-4.29 4.3-4.29zM13 5.83l1.88 1.88L13 9.59V5.83zm1.88 10.46L13 18.17v-3.76l1.88 1.88z" />
                        </svg>
                    </div>
                    <button class="btn btn-success" id="pauseBtn" onclick="togglePause()">Pause</button>
                    <button class="btn" onclick="saveData()">üíæ Save</button>
                    <button class="btn" onclick="document.getElementById('loadFileInput').click()">üìÅ Load</button>
                    <button class="btn btn-danger" onclick="clearData()">üóëÔ∏è Clear</button>
                    <button class="btn" onclick="showPage('main')">‚Üê Back</button>
                </div>
            </div>

            <div class="graph-container full-graph">
                <canvas id="fullGraph"></canvas>
                <div class="graph-legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #f00;"></div>
                        <span>Brew Temperature</span>
                        <span id="fullLegendTemp" style="margin-left: auto; font-weight: bold; color: #ff8888;"></span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #00f;"></div>
                        <span>Group Pressure</span>
                        <span id="fullLegendPressure"
                            style="margin-left: auto; font-weight: bold; color: #8888ff;"></span>
                    </div>
                </div>
                <div class="graph-tooltip"></div>
            </div>

            <div class="axis-controls">
                <div style="display: flex; flex-wrap: wrap; justify-content: center; gap: 1.5rem; align-items: center;">
                    <div class="settings-row">
                        <div class="settings-label">Temp</div>
                        <div class="settings-controls">
                            <input type="number" id="tempGraphMinInput" step="1" min="0">
                            <span style="font-size: 1.4rem; padding: 0 0.8rem;">‚Äì</span>
                            <input type="number" id="tempGraphMaxInput" step="1" min="0">
                        </div>
                    </div>
                    <div class="settings-row">
                        <div class="settings-label">Press</div>
                        <div class="settings-controls">
                            <input type="number" id="pressGraphMinInput" step="0.5" min="0">
                            <span style="font-size: 1.4rem; padding: 0 0.8rem;">‚Äì</span>
                            <input type="number" id="pressGraphMaxInput" step="0.5" min="0">
                        </div>
                    </div>
                    <button class="btn btn-primary" onclick="resetGraphScales()">Reset</button>
                </div>
            </div>

            <input type="file" id="loadFileInput" accept="application/json,.json" style="display:none;">
        </div>

        <div class="page" id="pidPage">
            <div class="header">
                <h2>PID Gains</h2>
                <div class="btn-group">
                    <button class="btn btn-danger" onclick="resetAllPID()">Reset Defaults</button>
                    <div class="ble-indicator disconnected" title="Bluetooth Status">
                        <svg width="28" height="28" viewBox="0 0 24 24" fill="currentColor">
                            <path
                                d="M17.71 7.71L12 2h-1v7.59L6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 11 14.41V22h1l5.71-5.71-4.3-4.29 4.3-4.29zM13 5.83l1.88 1.88L13 9.59V5.83zm1.88 10.46L13 18.17v-3.76l1.88 1.88z" />
                        </svg>
                    </div>
                    <button class="btn" onclick="showPage('settings')">‚Üê Back</button>
                </div>
            </div>
            <div id="pidZones"></div>
        </div>
    </div>

    <script>
        const installButton = document.getElementById('installButton');
        let deferredPrompt = null;
        let chooserOpen = false;


        window.addEventListener('beforeinstallprompt', (e) => {
            if (isAppInstalled()) {
                installButton.style.display = 'none';
                return;
            }
            e.preventDefault();
            deferredPrompt = e;
            installButton.style.display = 'block';
        });

        window.addEventListener('appinstalled', () => {
            document.getElementById('installButton').style.display = 'none';
            deferredPrompt = null;
        });

        function triggerInstall() {
            if (deferredPrompt) {
                deferredPrompt.prompt();
                deferredPrompt.userChoice.then((choice) => {
                    deferredPrompt = null;
                });
            } else {
                alert('To install this app:\n\n‚Ä¢ On iPhone/iPad (Safari): Tap Share ‚Üí Add to Home Screen\n‚Ä¢ On Android/Chrome: Tap menu ‚Üí Install app');
            }
        }

        function resetLiveData() {
            state.brewTemp = 0.0;
            state.steamTemp = 0.0;
            state.groupTemp = 0.0;
            state.groupPressure = 0.0;
            state.brewReady = false;
            state.steamReady = false;
            state.groupReady = false;
            state.shotRunning = false;

            // Directly reset shot timer display (in case no data was received yet)
            const shotElem = document.getElementById('shotTime');
            if (shotElem) {
                shotElem.textContent = '00';
                shotElem.classList.remove('running');
                shotElem.classList.add('stopped');
            }

            updateDisplay();
            drawMiniGraph();
            drawFullGraph();
        }

        window.addEventListener('load', () => {
            if (isAppInstalled()) {
                installButton.style.display = 'none';
            } else {
                installButton.style.display = 'none';
            }
        });

        let state = {
            bleDevice: null,
            bleConnected: false,
            characteristic: null,
            brewTemp: 0.0,
            steamTemp: 0.0,
            groupTemp: 0.0,
            groupPressure: 0.0,
            brewSetpoint: 93.0,
            steamSetpoint: 125.0,
            groupSetpoint: 92.0,
            brewReady: false,
            steamReady: false,
            groupReady: false,
            useFahrenheit: false,
            pressureIsBar: true,
            brightness: 200,
            shotRunning: false,
            shotTime: 0,
            tempHistory: [],
            pressureHistory: [],
            hasReceivedFirstData: false,
            dataCollectionPaused: false,
            tempGraphMin: 40,
            tempGraphMax: 120,
            pressGraphMin: 0,
            pressGraphMax: 12,
            pidGains: {
                brew: { consKp: 1.20, consKi: 0.06, consKd: 0.30, aggKp: 4.50, aggKi: 0.22, aggKd: 1.10 },
                steam: { consKp: 0.90, consKi: 0.04, consKd: 0.40, aggKp: 3.80, aggKi: 0.18, aggKd: 1.30 },
                group: { consKp: 1.40, consKi: 0.03, consKd: 0.80, aggKp: 5.00, aggKi: 0.12, aggKd: 2.00 }
            },
            lastDataTime: 0
        };

        let miniHoveredIndex = -1;
        let fullHoveredIndex = -1;

        let reconnectTimer = null;
        let reconnectAttempts = 0;
        const MAX_RECONNECT_ATTEMPTS = 0; // 0 = unlimited


        const miniTooltip = document.querySelector('.nav-graph .graph-tooltip');
        const fullTooltip = document.querySelector('.full-graph .graph-tooltip');

        function cToF(c) { return c * 9 / 5 + 32; }
        function fToC(f) { return (f - 32) * 5 / 9; }

        function smooth(prev, next, alpha = 0.2) {
            return prev == null ? next : prev + alpha * (next - prev);
        }

        async function toggleBLE() {
            if (state.bleConnected) {
                disconnectBLE();
                updateBLEUI();
                return;
            }

            let success = false;

            // If we have a previous device, try direct reconnect first (often no dialog)
            if (state.bleDevice) {
                try {
                    await connectBLE(true);
                    success = true;
                } catch (err) {
                    console.warn('Direct reconnect failed, falling back to device selection', err);
                }
            }

            // If direct failed or no previous device, use the full requestDevice flow
            if (!success) {
                state.bleDevice = null;  // clear stale reference
                try {
                    await connectBLE(false);  // this shows the Bluetooth chooser
                } catch (err) {
                    console.error('Connection failed:', err);
                    alert('Failed to connect to LVR-1. Check that it is powered on and in range.');
                }
            }
        }

        function disconnectBLE() {
            try {
                if (state.characteristic) {
                    state.characteristic.removeEventListener('characteristicvaluechanged', handleBLEData);
                }
                if (state.bleDevice?.gatt?.connected) {
                    state.bleDevice.gatt.disconnect();
                }
            } catch { }
            state.characteristic = null;
            state.bleConnected = false;
        }

        async function connectBLE(isReconnect = false) {
            if (!navigator.bluetooth) {
                alert('Web Bluetooth not supported');
                return;
            }

            if (!isReconnect && chooserOpen) {
                console.warn('Bluetooth chooser already open');
                return;
            }

            try {
                let device = state.bleDevice;
                if (!device || !isReconnect) {
                    device = await navigator.bluetooth.requestDevice({
                        filters: [{ name: 'LVR-1' }],
                        optionalServices: ['4fafc201-1fb5-459e-8fcc-c5c9c331914b']
                    });
                    state.bleDevice = device;
                    device.addEventListener('gattserverdisconnected', handleDisconnect);
                }
                const server = await device.gatt.connect();
                const service = await server.getPrimaryService('4fafc201-1fb5-459e-8fcc-c5c9c331914b');
                const characteristic = await service.getCharacteristic('beb5483e-36e1-4688-b7f5-ea07361b26a8');
                await characteristic.startNotifications();
                characteristic.addEventListener('characteristicvaluechanged', handleBLEData);
                state.characteristic = characteristic;
                state.bleConnected = true;
                state.lastDataTime = Date.now();
                reconnectAttempts = 0;

                if (reconnectTimer) {
                    clearInterval(reconnectTimer);
                    reconnectTimer = null;
                }

                updateBLEUI();
            } catch (err) {
                console.warn('LVR-1 connection failed:', err);
                throw err;
            }
        }

        // ==================== AUTO-CONNECT ADDITION ====================
        async function autoConnect() {
            if (!navigator.bluetooth || state.bleConnected) return;

            try {
                const devices = await navigator.bluetooth.getDevices();

                for (const device of devices) {
                    if (device.name !== 'LVR-1') continue;

                    state.bleDevice = device;
                    device.addEventListener('gattserverdisconnected', handleDisconnect);

                    // Try immediate connection first
                    try {
                        await connectBLE(true);
                        console.log('Auto-connected immediately to LVR-1');
                        return;
                    } catch (err) {
                        console.log('Immediate auto-connect failed ‚Äì watching for advertisements');
                    }

                    // If immediate fails, watch for advertisements
                    const abortController = new AbortController();

                    device.addEventListener('advertisementreceived', async () => {
                        abortController.abort();
                        console.log('LVR-1 advertisement received ‚Äì attempting connection');
                        try {
                            await connectBLE(true);
                            console.log('Auto-connected after advertisement');
                        } catch (err) {
                            console.error('Auto-connect after advertisement failed:', err);
                        }
                    }, { once: true });

                    try {
                        await device.watchAdvertisements({ signal: abortController.signal });
                    } catch (err) {
                        console.warn('watchAdvertisements error:', err);
                    }
                }
            } catch (err) {
                console.error('autoConnect error:', err);
            }
        }
        // ==============================================================

        function handleDisconnect() {
            state.bleConnected = false;
            state.characteristic = null;
            updateBLEUI();
            resetLiveData();
            scheduleAutoReconnect();
        }

        function updateBLEUI() {
            const connected = state.bleConnected;
            document.querySelectorAll('.ble-connect-btn').forEach(btn => {
                btn.textContent = connected ? 'Disconnect LVR-1' : 'Connect LVR-1';
                btn.classList.toggle('btn-primary', !connected);
                btn.classList.toggle('btn-danger', connected);
            });
            document.querySelectorAll('.ble-indicator').forEach(ind => {
                ind.classList.toggle('connected', connected);
                ind.classList.toggle('disconnected', !connected);
            });
            document.querySelector('.container').classList.toggle('ble-disconnected', !connected);
        }

        function handleBLEData(event) {
            const text = new TextDecoder().decode(event.target.value);
            let data;
            try { data = JSON.parse(text); } catch { return; }

            if (data.pid) {
                if (data.pid.brew) Object.assign(state.pidGains.brew, data.pid.brew);
                if (data.pid.steam) Object.assign(state.pidGains.steam, data.pid.steam);
                if (data.pid.group) Object.assign(state.pidGains.group, data.pid.group);
                renderPIDSettings();
                return;
            }

            state.lastDataTime = Date.now();

            Object.assign(state, {
                brewTemp: data.brewTemp ?? state.brewTemp,
                steamTemp: data.steamTemp ?? state.steamTemp,
                groupTemp: data.groupTemp ?? state.groupTemp,
                groupPressure: data.groupPressure ?? state.groupPressure,
                brewSetpoint: data.brewSetpoint ?? state.brewSetpoint,
                steamSetpoint: data.steamSetpoint ?? state.steamSetpoint,
                groupSetpoint: data.groupSetpoint ?? state.groupSetpoint,
                brewReady: data.brewReady ?? state.brewReady,
                steamReady: data.steamReady ?? state.steamReady,
                groupReady: data.groupReady ?? state.groupReady,
                brightness: data.brightness ?? state.brightness,
                useFahrenheit: data.useFahrenheit ?? state.useFahrenheit,
                pressureIsBar: data.pressureIsBar ?? state.pressureIsBar,
            });

            updateUnitButtons();

            if ('shotRunning' in data && 'shotSeconds' in data) {
                state.shotRunning = data.shotRunning;
                const secs = Math.max(0, Math.min(98, data.shotSeconds % 99));
                const shotElem = document.getElementById('shotTime');
                shotElem.textContent = String(secs).padStart(2, '0');
                shotElem.classList.toggle('running', state.shotRunning);
                shotElem.classList.toggle('stopped', !state.shotRunning);
            }

            if (!state.dataCollectionPaused) {
                state.tempHistory.push(state.brewTemp);
                state.pressureHistory.push(state.groupPressure);
                if (state.tempHistory.length > 600) {
                    state.tempHistory.shift();
                    state.pressureHistory.shift();
                }
                drawMiniGraph();
                drawFullGraph();
            }

            updateDisplay();
        }

        async function sendBLECommand(command) {
            if (!state.characteristic) return;
            try {
                const encoder = new TextEncoder();
                const data = encoder.encode(JSON.stringify(command));
                await state.characteristic.writeValueWithResponse(data);
            } catch (error) {
                console.error('BLE write failed ‚Äì forcing disconnect:', error);
                // Any write failure means the link is dead
                handleDisconnect();
                // Optional: give user feedback (uncomment if desired)
                alert('Connection lost to LVR-1');
            }
        }

        function showPage(pageName) {
            if (pageName !== 'main' && !state.bleConnected) {
                alert('Please connect to LVR-1 via BLE to access this page.');
                return;
            }

            document.querySelectorAll('.page').forEach(page => page.classList.remove('active'));
            document.getElementById(pageName + 'Page').classList.add('active');

            if (pageName === 'main') {
                requestAnimationFrame(() => requestAnimationFrame(() => drawMiniGraph()));
            }

            if (pageName === 'pid') {
                document.getElementById('pidZones').innerHTML = '<p>Loading PID values‚Ä¶</p>';
                sendBLECommand({ type: 'get_pid' });
            }

            if (pageName === 'graph') {
                drawFullGraph();
                syncAxisInputs();
                updateFullLegend();
            }

            if (pageName === 'settings') {
                updateUnitButtons();
                const slider = document.getElementById('brightnessSlider');
                if (slider) slider.value = state.brightness;
            }
        }

        function toggleTempUnit() {
            state.useFahrenheit = !state.useFahrenheit;
            document.getElementById('tempUnitBtn').textContent = state.useFahrenheit ? '¬∞F' : '¬∞C';
            if (state.bleConnected) {
                sendBLECommand({ type: 'unit', unitType: 'temp', value: state.useFahrenheit });
            }
            updateDisplay();
            drawMiniGraph();
            if (document.getElementById('graphPage').classList.contains('active')) {
                syncAxisInputs();
                drawFullGraph();
            }
        }

        function togglePressureUnit() {
            state.pressureIsBar = !state.pressureIsBar;
            document.getElementById('pressureUnitBtn').textContent = state.pressureIsBar ? 'bar' : 'psi';
            if (state.bleConnected) {
                sendBLECommand({ type: 'unit', unitType: 'pressure', value: state.pressureIsBar });
            }
            updateDisplay();
            drawMiniGraph();
            if (document.getElementById('graphPage').classList.contains('active')) {
                syncAxisInputs();
                drawFullGraph();
            }
        }

        function syncAxisInputs() {
            const tempMinDisp = state.useFahrenheit
                ? Math.round(cToF(state.tempGraphMin))
                : Math.round(state.tempGraphMin);
            const tempMaxDisp = state.useFahrenheit
                ? Math.round(cToF(state.tempGraphMax))
                : Math.round(state.tempGraphMax);

            document.getElementById('tempGraphMinInput').value = tempMinDisp;
            document.getElementById('tempGraphMaxInput').value = tempMaxDisp;

            const conv = state.pressureIsBar ? 1 : 14.5038;
            const decimals = state.pressureIsBar ? 1 : 0;
            const pressMinDisp = (state.pressGraphMin * conv).toFixed(decimals);
            const pressMaxDisp = (state.pressGraphMax * conv).toFixed(decimals);

            document.getElementById('pressGraphMinInput').value = pressMinDisp;
            document.getElementById('pressGraphMaxInput').value = pressMaxDisp;
        }

        function updateDisplay() {
            const tempUnit = state.useFahrenheit ? '¬∞F' : '¬∞C';

            // Fixed: update the actual value and unit spans (previous code targeted non-existent IDs like brewTempCard)
            const formatTemp = (val) => state.useFahrenheit ? cToF(val).toFixed(1) : val.toFixed(1);

            document.getElementById('brewTempValue').textContent = formatTemp(state.brewTemp);
            document.getElementById('brewTempUnit').textContent = tempUnit;

            document.getElementById('steamTempValue').textContent = formatTemp(state.steamTemp);
            document.getElementById('steamTempUnit').textContent = tempUnit;

            document.getElementById('groupTempValue').textContent = formatTemp(state.groupTemp);
            document.getElementById('groupTempUnit').textContent = tempUnit;

            // Status card ready/heating classes
            document.getElementById('brewStatus').className = 'status-card ' +
                (state.bleConnected && state.brewReady ? 'ready' : state.bleConnected ? 'heating' : '');
            document.getElementById('steamStatus').className = 'status-card ' +
                (state.bleConnected && state.steamReady ? 'ready' : state.bleConnected ? 'heating' : '');
            document.getElementById('groupStatus').className = 'status-card ' +
                (state.bleConnected && state.groupReady ? 'ready' : state.bleConnected ? 'heating' : '');

            // Pressure (already correct, kept as-is)
            const pressureValue = state.pressureIsBar ? state.groupPressure : state.groupPressure * 14.5038;
            document.getElementById('pressureDisplay').textContent = pressureValue.toFixed(1);
            document.getElementById('pressureUnit').textContent = state.pressureIsBar ? 'bar' : 'psi';

            // Setpoints
            document.getElementById('brewSetpointDisplay').textContent = formatTemp(state.brewSetpoint) + ' ' + tempUnit;
            document.getElementById('steamSetpointDisplay').textContent = formatTemp(state.steamSetpoint) + ' ' + tempUnit;
            document.getElementById('groupSetpointDisplay').textContent = formatTemp(state.groupSetpoint) + ' ' + tempUnit;

            updateUnitButtons();
            updateFullLegend();
        }

        function updateBrightness(value) {
            state.brightness = parseInt(value);
            sendBLECommand({ type: 'brightness', value: state.brightness });
        }

        function adjustSetpoint(zone, delta) {
            if (zone === 'brew') {
                state.brewSetpoint = Math.max(80, Math.min(100, state.brewSetpoint + delta));
                sendBLECommand({ type: 'setpoint', zone: 'brew', value: state.brewSetpoint });
            } else if (zone === 'steam') {
                state.steamSetpoint = Math.max(110, Math.min(140, state.steamSetpoint + delta));
                sendBLECommand({ type: 'setpoint', zone: 'steam', value: state.steamSetpoint });
            } else if (zone === 'group') {
                state.groupSetpoint = Math.max(80, Math.min(98, state.groupSetpoint + delta));
                sendBLECommand({ type: 'setpoint', zone: 'group', value: state.groupSetpoint });
            }
            updateDisplay();
        }

        function setupHiDPICanvas(canvas) {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = Math.round(rect.width * dpr);
            canvas.height = Math.round(rect.height * dpr);
            const ctx = canvas.getContext('2d');
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            return ctx;
        }

        let lastTemp = null;
        let lastPressure = null;

        setInterval(() => {
            if (state.bleConnected && Date.now() - state.lastDataTime > 5000) {  // 10s no data
                console.warn('No data received for 10s ‚Äì forcing disconnect');
                handleDisconnect();
            }
        }, 5000);

        setInterval(() => {
            if (state.bleConnected && state.characteristic) sendBLECommand({ type: "ping" });
        }, 3000);

        setInterval(() => {
            if (state.bleConnected && (!state.bleDevice || !state.bleDevice.gatt.connected)) handleDisconnect();
        }, 1000);

        setInterval(() => {
            if (!state.bleConnected || !state.hasReceivedFirstData) return;
            if (!state.dataCollectionPaused) {
                lastTemp = smooth(lastTemp, state.brewTemp);
                lastPressure = smooth(lastPressure, state.groupPressure);
                state.tempHistory.push(lastTemp);
                state.pressureHistory.push(lastPressure);
                if (state.tempHistory.length > 600) {
                    state.tempHistory.shift();
                    state.pressureHistory.shift();
                }
            }
            drawMiniGraph();
            if (document.getElementById('graphPage').classList.contains('active')) drawFullGraph();
        }, 1000);

        function drawMiniGraph() {
            const canvas = document.getElementById('miniGraph');
            if (!canvas) return;

            const ctx = setupHiDPICanvas(canvas);
            const rect = canvas.getBoundingClientRect();
            const width = rect.width;
            const height = rect.height;

            ctx.clearRect(0, 0, width, height);
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);

            const padding = 40;

            const tempMin = 40;
            const tempMax = 120;
            const tempRange = tempMax - tempMin;

            const pressureMin = 0;
            const pressureMax = 12;
            const pressureRange = pressureMax - pressureMin;

            const tempUnit = state.useFahrenheit ? '¬∞F' : '¬∞C';
            const dispTempMin = state.useFahrenheit ? cToF(tempMin) : tempMin;
            const dispTempMax = state.useFahrenheit ? cToF(tempMax) : tempMax;
            const dispTempRange = dispTempMax - dispTempMin;

            const pressureUnit = state.pressureIsBar ? 'bar' : 'psi';
            const pressureConv = state.pressureIsBar ? 1 : 14.5038;
            const pressureDecimals = state.pressureIsBar ? 1 : 0;
            const dispPressureMin = pressureMin * pressureConv;
            const dispPressureMax = pressureMax * pressureConv;
            const dispPressureRange = dispPressureMax - dispPressureMin;

            ctx.strokeStyle = '#222';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = padding + (i / 4) * (height - padding * 2);
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(width - padding, y);
                ctx.stroke();
            }

            ctx.strokeStyle = '#800';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, height - padding);
            ctx.stroke();

            ctx.strokeStyle = '#008';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(width - padding, padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();

            ctx.fillStyle = '#f88';
            ctx.font = '10px monospace';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            const miniTicks = 2;
            for (let i = 0; i <= miniTicks; i++) {
                const fraction = i / miniTicks;
                const y = padding + fraction * (height - padding * 2);
                const val = dispTempMax - fraction * dispTempRange;
                ctx.fillText(val.toFixed(1), padding - 8, y);
            }
            ctx.fillText(tempUnit, padding - 8, padding + 10);

            ctx.fillStyle = '#88f';
            ctx.textAlign = 'left';
            for (let i = 0; i <= miniTicks; i++) {
                const fraction = i / miniTicks;
                const y = padding + fraction * (height - padding * 2);
                const val = dispPressureMax - fraction * dispPressureRange;
                ctx.fillText(val.toFixed(pressureDecimals), width - padding + 8, y);
            }
            ctx.fillText(pressureUnit, width - padding + 8, padding + 10);

            ctx.fillStyle = '#888';
            ctx.font = '11px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('Time ‚Üí', width / 2, height - 6);

            if (state.tempHistory.length === 0) {
                ctx.fillStyle = '#888';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(state.bleConnected ? 'Collecting data...' : 'Connect to view live graph', width / 2, height / 2);
                return;
            }

            const plot = (data, color, minV, rangeV) => {
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                data.forEach((v, i) => {
                    const x = padding + (i / (data.length - 1)) * (width - padding * 2);
                    let fraction = (v - minV) / rangeV;
                    fraction = Math.max(0, Math.min(1, fraction));
                    const y = height - padding - fraction * (height - padding * 2);
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();
            };

            plot(state.tempHistory, '#f00', tempMin, tempRange);
            plot(state.pressureHistory, '#00f', pressureMin, pressureRange);

            if (miniHoveredIndex >= 0 && miniHoveredIndex < state.tempHistory.length) {
                const index = miniHoveredIndex;
                const x = padding + (index / (state.tempHistory.length - 1)) * (width - padding * 2);

                ctx.strokeStyle = '#aaa';
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.moveTo(x, padding);
                ctx.lineTo(x, height - padding);
                ctx.stroke();
                ctx.setLineDash([]);

                let fractionTemp = (state.tempHistory[index] - tempMin) / tempRange;
                fractionTemp = Math.max(0, Math.min(1, fractionTemp));
                const yTemp = height - padding - fractionTemp * (height - padding * 2);
                ctx.fillStyle = '#f00';
                ctx.beginPath();
                ctx.arc(x, yTemp, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();

                let fractionPress = (state.pressureHistory[index] - pressureMin) / pressureRange;
                fractionPress = Math.max(0, Math.min(1, fractionPress));
                const yPress = height - padding - fractionPress * (height - padding * 2);
                ctx.fillStyle = '#00f';
                ctx.beginPath();
                ctx.arc(x, yPress, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        function updateFullLegend() {
            const tempEl = document.getElementById('fullLegendTemp');
            const pressEl = document.getElementById('fullLegendPressure');
            if (!tempEl || !pressEl) return;

            const tempVal = (state.useFahrenheit ? cToF(state.brewTemp) : state.brewTemp).toFixed(1);
            const tempUnit = state.useFahrenheit ? '¬∞F' : '¬∞C';
            tempEl.textContent = `${tempVal} ${tempUnit}`;

            const pressVal = (state.pressureIsBar ? state.groupPressure : state.groupPressure * 14.5038).toFixed(1);
            const pressUnit = state.pressureIsBar ? 'bar' : 'psi';
            pressEl.textContent = `${pressVal} ${pressUnit}`;
        }

        function drawFullGraph() {
            const canvas = document.getElementById('fullGraph');
            if (!canvas) return;

            const ctx = setupHiDPICanvas(canvas);
            const width = canvas.getBoundingClientRect().width;
            const height = canvas.getBoundingClientRect().height;

            ctx.clearRect(0, 0, width, height);
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);

            const paddingTop = 30;
            const paddingBottom = 30;
            const paddingLeft = 65;
            const paddingRight = 65;
            const plotWidth = width - paddingLeft - paddingRight;
            const plotHeight = height - paddingTop - paddingBottom;

            let tempMin = state.tempGraphMin;
            let tempMax = state.tempGraphMax;
            let tempRange = tempMax - tempMin;
            if (tempRange <= 0) {
                tempRange = 80;
                tempMin = tempMax - tempRange;
            }

            let pressureMin = state.pressGraphMin;
            let pressureMax = state.pressGraphMax;
            let pressureRange = pressureMax - pressureMin;
            if (pressureRange <= 0) {
                pressureRange = 12;
                pressureMin = pressureMax - pressureRange;
            }

            const tempUnit = state.useFahrenheit ? '¬∞F' : '¬∞C';
            const dispTempMin = state.useFahrenheit ? cToF(tempMin) : tempMin;
            const dispTempMax = state.useFahrenheit ? cToF(tempMax) : tempMax;
            const dispTempRange = dispTempMax - dispTempMin;

            const pressureUnit = state.pressureIsBar ? 'bar' : 'psi';
            const pressureConv = state.pressureIsBar ? 1 : 14.5038;
            const pressureDecimals = state.pressureIsBar ? 1 : 0;
            const dispPressureMin = pressureMin * pressureConv;
            const dispPressureMax = pressureMax * pressureConv;
            const dispPressureRange = dispPressureMax - dispPressureMin;

            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            for (let i = 1; i < 5; i++) {
                const y = paddingTop + (i / 5) * plotHeight;
                ctx.beginPath();
                ctx.moveTo(paddingLeft, y);
                ctx.lineTo(width - paddingRight, y);
                ctx.stroke();
                const x = paddingLeft + (i / 5) * plotWidth;
                ctx.beginPath();
                ctx.moveTo(x, paddingTop);
                ctx.lineTo(x, height - paddingBottom);
                ctx.stroke();
            }

            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;
            ctx.strokeRect(paddingLeft, paddingTop, plotWidth, plotHeight);

            ctx.strokeStyle = '#800';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(paddingLeft, paddingTop);
            ctx.lineTo(paddingLeft, height - paddingBottom);
            ctx.stroke();

            ctx.strokeStyle = '#008';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(width - paddingRight, paddingTop);
            ctx.lineTo(width - paddingRight, height - paddingBottom);
            ctx.stroke();

            ctx.fillStyle = '#f88';
            ctx.font = '14px monospace';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            const fullTicks = 4;
            for (let i = 0; i <= fullTicks; i++) {
                const fraction = i / fullTicks;
                const y = paddingTop + fraction * plotHeight;
                const val = dispTempMax - fraction * dispTempRange;
                ctx.fillText(val.toFixed(1), paddingLeft - 10, y);
            }
            ctx.fillText(tempUnit, paddingLeft - 10, paddingTop + 15);

            ctx.fillStyle = '#88f';
            ctx.textAlign = 'left';
            for (let i = 0; i <= fullTicks; i++) {
                const fraction = i / fullTicks;
                const y = paddingTop + fraction * plotHeight;
                const val = dispPressureMax - fraction * dispPressureRange;
                ctx.fillText(val.toFixed(pressureDecimals), width - paddingRight + 10, y);
            }
            ctx.fillText(pressureUnit, width - paddingRight + 10, paddingTop + 15);

            if (state.tempHistory.length === 0) {
                ctx.fillStyle = '#666';
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('No data collected yet', width / 2, height / 2);
                return;
            }

            const plot = (data, color, minV, rangeV) => {
                ctx.strokeStyle = color;
                ctx.lineWidth = 3;
                ctx.beginPath();
                data.forEach((v, i) => {
                    const x = paddingLeft + (i / (data.length - 1)) * plotWidth;
                    let fraction = (v - minV) / rangeV;
                    fraction = Math.max(0, Math.min(1, fraction));
                    const y = paddingTop + (1 - fraction) * plotHeight;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();
            };

            plot(state.tempHistory, '#f00', tempMin, tempRange);
            plot(state.pressureHistory, '#00f', pressureMin, pressureRange);

            if (fullHoveredIndex >= 0 && fullHoveredIndex < state.tempHistory.length) {
                const index = fullHoveredIndex;
                const x = paddingLeft + (index / (state.tempHistory.length - 1)) * plotWidth;

                ctx.strokeStyle = '#aaa';
                ctx.lineWidth = 1;
                ctx.setLineDash([6, 6]);
                ctx.beginPath();
                ctx.moveTo(x, paddingTop);
                ctx.lineTo(x, height - paddingBottom);
                ctx.stroke();
                ctx.setLineDash([]);

                let fractionTemp = (state.tempHistory[index] - tempMin) / tempRange;
                fractionTemp = Math.max(0, Math.min(1, fractionTemp));
                const yTemp = paddingTop + (1 - fractionTemp) * plotHeight;
                ctx.fillStyle = '#f00';
                ctx.beginPath();
                ctx.arc(x, yTemp, 7, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                ctx.stroke();

                let fractionPress = (state.pressureHistory[index] - pressureMin) / pressureRange;
                fractionPress = Math.max(0, Math.min(1, fractionPress));
                const yPress = paddingTop + (1 - fractionPress) * plotHeight;
                ctx.fillStyle = '#00f';
                ctx.beginPath();
                ctx.arc(x, yPress, 7, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                ctx.stroke();
            }
        }

        function handleGraphHover(event, canvasId) {
            event.preventDefault();
            const canvas = document.getElementById(canvasId);
            const rect = canvas.getBoundingClientRect();
            const isTouch = event.touches !== undefined;
            const clientX = isTouch ? event.touches[0].clientX : event.clientX;
            const relX = clientX - rect.left;

            if (relX < 0 || relX > rect.width) {
                handleGraphLeave(canvasId);
                return;
            }

            const isMini = canvasId === 'miniGraph';

            const paddingLeft = isMini ? 40 : 65;
            const paddingRight = isMini ? 40 : 65;
            const paddingTop = isMini ? 40 : 30;
            const paddingBottom = isMini ? 40 : 30;

            const plotStart = paddingLeft;
            const plotEnd = rect.width - paddingRight;
            if (relX < plotStart || relX > plotEnd) {
                handleGraphLeave(canvasId);
                return;
            }

            const fraction = (relX - plotStart) / (plotEnd - plotStart);
            const maxIndex = state.tempHistory.length - 1;
            if (maxIndex < 0) return;

            const index = Math.round(fraction * maxIndex);
            if (isMini) miniHoveredIndex = index;
            else fullHoveredIndex = index;

            const tempMin = isMini ? 40 : state.tempGraphMin;
            const tempMax = isMini ? 120 : state.tempGraphMax;
            let tempRange = tempMax - tempMin;
            if (tempRange <= 0) tempRange = 80;

            const pressureMin = isMini ? 0 : state.pressGraphMin;
            const pressureMax = isMini ? 12 : state.pressGraphMax;
            let pressureRange = pressureMax - pressureMin;
            if (pressureRange <= 0) pressureRange = 12;

            const plotWidth = rect.width - paddingLeft - paddingRight;
            const plotHeight = rect.height - paddingTop - paddingBottom;

            const x_canvas = paddingLeft + fraction * plotWidth;

            let fractionTemp = (state.tempHistory[index] - tempMin) / tempRange;
            fractionTemp = Math.max(0, Math.min(1, fractionTemp));
            const y_temp_canvas = isMini
                ? rect.height - paddingBottom - fractionTemp * plotHeight
                : paddingTop + (1 - fractionTemp) * plotHeight;

            let fractionPress = (state.pressureHistory[index] - pressureMin) / pressureRange;
            fractionPress = Math.max(0, Math.min(1, fractionPress));
            const y_press_canvas = isMini
                ? rect.height - paddingBottom - fractionPress * plotHeight
                : paddingTop + (1 - fractionPress) * plotHeight;

            const container = canvas.parentElement.getBoundingClientRect();

            const pointX = rect.left - container.left + x_canvas;
            const pointYTemp = rect.top - container.top + y_temp_canvas;
            const pointYPress = rect.top - container.top + y_press_canvas;

            const centerY = (pointYTemp + pointYPress) / 2;

            const tempUnit = state.useFahrenheit ? '¬∞F' : '¬∞C';
            const pressureUnit = state.pressureIsBar ? 'bar' : 'psi';
            const pressureConv = state.pressureIsBar ? 1 : 14.5038;
            const pressureDecimals = state.pressureIsBar ? 1 : 0;

            const tempVal = state.useFahrenheit ? cToF(state.tempHistory[index]) : state.tempHistory[index];
            const pressVal = state.pressureHistory[index] * pressureConv;
            const timeSec = index;

            const html = `
                <strong>Time: ${timeSec}s</strong><br>
                Temp: ${tempVal.toFixed(1)}${tempUnit}<br>
                Press: ${pressVal.toFixed(pressureDecimals)}${pressureUnit}
            `;

            const tooltip = isMini ? miniTooltip : fullTooltip;
            tooltip.innerHTML = html;
            tooltip.style.display = 'block';

            let tooltipX = pointX + 14;
            let tooltipY = centerY - tooltip.offsetHeight / 2;

            const containerRect = canvas.parentElement.getBoundingClientRect();
            if (tooltipX + tooltip.offsetWidth > containerRect.width - 8) {
                tooltipX = pointX - tooltip.offsetWidth - 14;
            }

            tooltipY = Math.max(8, Math.min(containerRect.height - tooltip.offsetHeight - 8, tooltipY));

            tooltip.style.left = Math.round(tooltipX) + 'px';
            tooltip.style.top = Math.round(tooltipY) + 'px';

            if (isMini) drawMiniGraph();
            else drawFullGraph();
        }

        function handleGraphLeave(canvasId) {
            if (canvasId === 'miniGraph') {
                miniHoveredIndex = -1;
                miniTooltip.style.display = 'none';
                drawMiniGraph();
            } else {
                fullHoveredIndex = -1;
                fullTooltip.style.display = 'none';
                drawFullGraph();
            }
        }

        const miniCanvas = document.getElementById('miniGraph');
        const fullCanvas = document.getElementById('fullGraph');

        miniCanvas.addEventListener('mousemove', e => handleGraphHover(e, 'miniGraph'));
        miniCanvas.addEventListener('touchmove', e => handleGraphHover(e, 'miniGraph'), { passive: false });
        miniCanvas.addEventListener('mouseleave', () => handleGraphLeave('miniGraph'));
        miniCanvas.addEventListener('touchend', () => handleGraphLeave('miniGraph'));

        fullCanvas.addEventListener('mousemove', e => handleGraphHover(e, 'fullGraph'));
        fullCanvas.addEventListener('touchmove', e => handleGraphHover(e, 'fullGraph'), { passive: false });
        fullCanvas.addEventListener('mouseleave', () => handleGraphLeave('fullGraph'));
        fullCanvas.addEventListener('touchend', () => handleGraphLeave('fullGraph'));

        function togglePause() {
            state.dataCollectionPaused = !state.dataCollectionPaused;
            const btn = document.getElementById('pauseBtn');
            btn.textContent = state.dataCollectionPaused ? 'Resume' : 'Pause';
            btn.classList.toggle('btn-danger', state.dataCollectionPaused);
            btn.classList.toggle('btn-success', !state.dataCollectionPaused);
        }

        function saveData() {
            if (state.tempHistory.length === 0) {
                alert('No data to save yet.');
                return;
            }
            const data = {
                tempHistory: state.tempHistory,
                pressureHistory: state.pressureHistory,
                savedAt: new Date().toISOString(),
                note: 'LVR-1 graph data (brew temperature and group pressure)'
            };
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `lvr1-graph-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function clearData() {
            if (!confirm('Clear all recorded graph data? This cannot be undone.')) return;
            state.tempHistory = [];
            state.pressureHistory = [];
            lastTemp = null;
            lastPressure = null;
            miniHoveredIndex = -1;
            fullHoveredIndex = -1;
            miniTooltip.style.display = 'none';
            fullTooltip.style.display = 'none';
            drawMiniGraph();
            drawFullGraph();
        }

        document.getElementById('loadFileInput').addEventListener('change', e => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = ev => {
                try {
                    const data = JSON.parse(ev.target.result);
                    if (!Array.isArray(data.tempHistory) || !Array.isArray(data.pressureHistory)) throw new Error('Invalid format');
                    const len = Math.min(data.tempHistory.length, data.pressureHistory.length);
                    state.tempHistory = data.tempHistory.slice(-len).map(Number);
                    state.pressureHistory = data.pressureHistory.slice(-len).map(Number);
                    lastTemp = state.tempHistory.length > 0 ? state.tempHistory[state.tempHistory.length - 1] : null;
                    lastPressure = state.pressureHistory.length > 0 ? state.pressureHistory[state.pressureHistory.length - 1] : null;
                    if (state.tempHistory.length > 0) {
                        state.brewTemp = state.tempHistory[state.tempHistory.length - 1];
                        state.groupPressure = state.pressureHistory[state.pressureHistory.length - 1];
                    }
                    updateDisplay();  // this will also call updateFullLegend()
                    drawMiniGraph();
                    drawFullGraph();
                    alert('Data loaded successfully (' + state.tempHistory.length + ' samples).');
                } catch (err) {
                    alert('Failed to load file: ' + err.message);
                }
            };
            reader.readAsText(file);
            e.target.value = '';
        });

        function updatePIDFromInput(input, zone, param) {
            let val = parseFloat(input.value);
            if (isNaN(val) || val < 0) val = 0;
            if (param.includes('Ki')) val = Math.round(val * 100) / 100;
            else val = Math.round(val * 10) / 10;
            state.pidGains[zone][param] = val;
            input.value = val.toFixed(2);
            sendBLECommand({ type: 'pid', zone: zone, gains: state.pidGains[zone] });
        }

        function adjustPID(zone, param, delta) {
            let newVal = Math.max(0, state.pidGains[zone][param] + delta);
            if (param.includes('Ki')) newVal = Math.round(newVal * 100) / 100;
            else newVal = Math.round(newVal * 10) / 10;
            state.pidGains[zone][param] = newVal;
            const input = document.getElementById(`${zone}-${param}`);
            if (input) input.value = newVal.toFixed(2);
            sendBLECommand({ type: 'pid', zone: zone, gains: state.pidGains[zone] });
        }

        function renderPIDSettings() {
            const container = document.getElementById('pidZones');
            container.innerHTML = '';

            ['brew', 'steam', 'group'].forEach(zone => {
                const div = document.createElement('div');
                div.className = 'pid-zone';

                let html = `
                    <h3>${zone.charAt(0).toUpperCase() + zone.slice(1)} Boiler</h3>
                    <div class="pid-grid">
                        <div class="pid-header aggressive">Aggressive</div>
                        <div class="pid-header conservative">Conservative</div>
                `;

                const params = [
                    { key: 'Kp', delta: 0.1, step: '0.1' },
                    { key: 'Ki', delta: 0.01, step: '0.01' },
                    { key: 'Kd', delta: 0.1, step: '0.1' }
                ];

                params.forEach(p => {
                    const aggKey = 'agg' + p.key;
                    const consKey = 'cons' + p.key;

                    html += `
                        <div class="pid-label">${p.key}:</div>
                        <div class="pid-cell">
                            <button class="btn btn-danger btn-pid" onclick="adjustPID('${zone}', '${aggKey}', -${p.delta})">‚àí</button>
                            <input type="number" class="pid-input" id="${zone}-${aggKey}"
                                   value="${state.pidGains[zone][aggKey].toFixed(2)}"
                                   step="${p.step}" min="0"
                                   onchange="updatePIDFromInput(this, '${zone}', '${aggKey}')">
                            <button class="btn btn-success btn-pid" onclick="adjustPID('${zone}', '${aggKey}', ${p.delta})">+</button>
                        </div>
                        <div class="pid-cell">
                            <button class="btn btn-danger btn-pid" onclick="adjustPID('${zone}', '${consKey}', -${p.delta})">‚àí</button>
                            <input type="number" class="pid-input" id="${zone}-${consKey}"
                                   value="${state.pidGains[zone][consKey].toFixed(2)}"
                                   step="${p.step}" min="0"
                                   onchange="updatePIDFromInput(this, '${zone}', '${consKey}')">
                            <button class="btn btn-success btn-pid" onclick="adjustPID('${zone}', '${consKey}', ${p.delta})">+</button>
                        </div>
                    `;
                });

                html += `</div>`;
                div.innerHTML = html;
                container.appendChild(div);
            });
        }

        function resetAllPID() {
            if (!confirm("Reset ALL PID gains to factory defaults? This cannot be undone.")) return;
            const defaults = { consKp: 1.00, consKi: 0.05, consKd: 0.25, aggKp: 4.00, aggKi: 0.20, aggKd: 1.00 };
            ['brew', 'steam', 'group'].forEach(zone => {
                state.pidGains[zone] = { ...defaults };
                if (state.bleConnected) sendBLECommand({ type: 'pid', zone: zone, gains: state.pidGains[zone] });
            });
            renderPIDSettings();
        }

        function updateGraphScales() {
            let dispMinT = parseFloat(document.getElementById('tempGraphMinInput').value);
            let dispMaxT = parseFloat(document.getElementById('tempGraphMaxInput').value);
            let dispMinP = parseFloat(document.getElementById('pressGraphMinInput').value);
            let dispMaxP = parseFloat(document.getElementById('pressGraphMaxInput').value);

            const minT = state.useFahrenheit ? fToC(dispMinT) : dispMinT;
            const maxT = state.useFahrenheit ? fToC(dispMaxT) : dispMaxT;
            const minP = state.pressureIsBar ? dispMinP : dispMinP / 14.5038;
            const maxP = state.pressureIsBar ? dispMaxP : dispMaxP / 14.5038;

            // Clamp to safe ranges (base units: ¬∞C and bar)
            let finalMinT = isNaN(minT) ? state.tempGraphMin : Math.max(0, minT);
            let finalMaxT = isNaN(maxT) ? state.tempGraphMax : Math.min(120, maxT);
            let finalMinP = isNaN(minP) ? state.pressGraphMin : Math.max(0, minP);
            let finalMaxP = isNaN(maxP) ? state.pressGraphMax : Math.min(16, maxP);

            // Enforce min < max with reasonable separation
            if (finalMinT >= finalMaxT) {
                finalMaxT = finalMinT + 40;  // give a decent visible range
                if (finalMaxT > 120) {
                    finalMaxT = 120;
                    finalMinT = 80;  // fallback safe range
                }
            }
            if (finalMinP >= finalMaxP) {
                finalMaxP = finalMinP + 4;
                if (finalMaxP > 16) {
                    finalMaxP = 16;
                    finalMinP = 12;
                }
            }

            // Round and store
            state.tempGraphMin = Math.round(finalMinT);
            state.tempGraphMax = Math.round(finalMaxT);
            state.pressGraphMin = finalMinP.toFixed(2);  // keep some precision
            state.pressGraphMax = finalMaxP.toFixed(2);

            syncAxisInputs();
            drawFullGraph();
        }

        function resetGraphScales() {
            state.tempGraphMin = 40;
            state.tempGraphMax = 120;
            state.pressGraphMin = 0;
            state.pressGraphMax = 12;
            syncAxisInputs();
            drawFullGraph();
        }

        function setupGraphObservers() {
            const miniContainer = document.querySelector('.nav-graph');
            if (miniContainer) new ResizeObserver(() => drawMiniGraph()).observe(miniContainer);
            const fullContainer = document.querySelector('.full-graph');
            if (fullContainer) new ResizeObserver(() => drawFullGraph()).observe(fullContainer);
        }

        setupGraphObservers();

        window.addEventListener('load', () => {
            drawMiniGraph();
            updateDisplay();
            syncAxisInputs();
            updateBLEUI(); // Ensure initial disconnected state is applied
            ['tempGraphMinInput', 'tempGraphMaxInput', 'pressGraphMinInput', 'pressGraphMaxInput'].forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.addEventListener('input', updateGraphScales);
                    el.addEventListener('change', updateGraphScales);
                }
            });
            autoConnect();
        });

        function updateUnitButtons() {
            const tempBtn = document.getElementById('tempUnitBtn');
            const pressureBtn = document.getElementById('pressureUnitBtn');
            if (tempBtn) tempBtn.textContent = state.useFahrenheit ? '¬∞F' : '¬∞C';
            if (pressureBtn) pressureBtn.textContent = state.pressureIsBar ? 'bar' : 'psi';
        }

        function isAppInstalled() {
            return window.matchMedia('(display-mode: standalone)').matches ||
                window.matchMedia('(display-mode: window-controls-overlay)').matches ||
                window.navigator.standalone === true;
        }

        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js');
        }

        function scheduleAutoReconnect() {
            if (reconnectTimer) return;
            if (!state.bleDevice) return;

            reconnectTimer = setInterval(async () => {
                if (state.bleConnected) {
                    clearInterval(reconnectTimer);
                    reconnectTimer = null;
                    return;
                }

                if (MAX_RECONNECT_ATTEMPTS &&
                    reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
                    clearInterval(reconnectTimer);
                    reconnectTimer = null;
                    console.warn('Max reconnect attempts reached');
                    return;
                }

                reconnectAttempts++;

                try {
                    console.log('Attempting auto-reconnect‚Ä¶');
                    await connectBLE(true); // ‚Üê no chooser
                    console.log('Auto-reconnect successful');
                } catch (err) {
                    console.log('Auto-reconnect failed, retrying‚Ä¶');
                }
            }, 3000); // every 3 seconds
        }

    </script>
</body>

</html>