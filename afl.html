<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AFL Fixture to Calendar</title>
    <link rel="icon" type="image/png" href="afl-32x32.png">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #2c2c2c;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            width: 90%;
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: #003087;
            color: white;
            padding: 40px 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2rem;
            margin-bottom: 0;
            font-weight: 700;
        }

        .content {
            padding: 30px;
        }

        .section {
            margin-bottom: 30px;
        }

        .section-title {
            font-size: 1.3rem;
            font-weight: 700;
            margin-bottom: 15px;
            color: #000;
        }

        .teams-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
        }
        
        @media (min-width: 900px) {
            .teams-grid {
                grid-template-columns: repeat(4, 1fr);
            }
        }

        .team-checkbox {
            display: flex;
            align-items: center;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
            background: white;
        }

        .team-checkbox:hover {
            border-color: #003087;
            background: #fef5f7;
        }

        .team-checkbox input[type="checkbox"] {
            margin-right: 10px;
            cursor: pointer;
            width: 18px;
            height: 18px;
            accent-color: #003087;
        }

        .team-checkbox label {
            cursor: pointer;
            flex: 1;
            user-select: none;
            display: flex;
            align-items: center;
            gap: 8px;
            color: #333;
            font-weight: 500;
        }

        .team-logo {
            width: 24px;
            height: 24px;
            object-fit: contain;
        }

        .team-checkbox input[type="checkbox"]:checked + label {
            font-weight: 700;
            color: #003087;
        }


        .auth-section {
            margin-bottom: 20px;
        }

        .auth-btn {
            width: 50%;
            margin: 0 auto;
            padding: 16px;
            background: #4285f4;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        @media (max-width: 768px) {
            .auth-btn {
                width: 90%;
            }
        }

        .auth-btn:hover {
            background: #357ae8;
            box-shadow: 0 2px 8px rgba(66, 133, 244, 0.3);
        }

        .auth-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .generate-btn {
            width: 50%;
            margin: 0 auto;
            display: block;
            padding: 16px;
            background: #003087;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 1.1rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s;
        }

        @media (max-width: 768px) {
            .generate-btn {
                width: 90%;
            }
        }

        .generate-btn:hover {
            background: #002366;
            box-shadow: 0 2px 8px rgba(226, 25, 55, 0.3);
        }

        .generate-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .manage-btn-container {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            width: 50%;
            margin-left: auto;
            margin-right: auto;
        }

        @media (max-width: 1200px) {
            .manage-btn-container {
                width: 70%;
            }
        }

        @media (max-width: 900px) {
            .manage-btn-container {
                width: 90%;
                flex-direction: column;
            }
        }

        .manage-btn {
            flex: 1;
            padding: 12px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.95rem;
            transition: all 0.3s;
        }

        .manage-btn:hover:not(:disabled) {
            opacity: 0.9;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .manage-btn:disabled {
            background: #ccc !important;
            cursor: not-allowed;
        }

        /* Toast Notifications */
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-width: 400px;
        }

        .toast {
            background: #e8e8e8;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            padding: 16px 20px;
            display: flex;
            align-items: flex-start;
            gap: 12px;
            animation: slideIn 0.3s ease-out;
            min-width: 300px;
            max-width: 400px;
        }

        .toast.error {
            border-left: 4px solid #f44336;
        }

        .toast.success {
            border-left: 4px solid #4caf50;
        }

        .toast.loading {
            border-left: 4px solid #2196F3;
        }

        .toast.warning {
            border-left: 4px solid #ff9800;
        }

        .toast.info {
            border-left: 4px solid #2196F3;
        }

        .toast-icon {
            flex-shrink: 0;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
        }

        .toast.error .toast-icon {
            background: #ffebee;
            color: #f44336;
        }

        .toast.success .toast-icon {
            background: #e8f5e9;
            color: #4caf50;
        }

        .toast.loading .toast-icon {
            background: #e3f2fd;
            color: #2196F3;
        }

        .toast.warning .toast-icon {
            background: #fff3e0;
            color: #ff9800;
        }

        .toast.info .toast-icon {
            background: #e3f2fd;
            color: #2196F3;
        }

        /* Spinner for loading toasts */
        .toast-spinner {
            width: 16px;
            height: 16px;
            border: 2px solid #e3f2fd;
            border-top: 2px solid #2196F3;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .toast-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .toast-title {
            font-weight: 700;
            font-size: 14px;
            color: #333;
        }

        .toast-message {
            font-size: 13px;
            color: #666;
            line-height: 1.4;
        }

        .toast-close {
            flex-shrink: 0;
            background: none;
            border: none;
            color: #999;
            font-size: 20px;
            cursor: pointer;
            padding: 0;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: color 0.2s;
        }

        .toast-close:hover {
            color: #333;
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(400px);
                opacity: 0;
            }
        }

        .toast.removing {
            animation: slideOut 0.3s ease-in forwards;
        }

        @media (max-width: 768px) {
            .toast-container {
                right: 10px;
                left: 10px;
                max-width: none;
            }

            .toast {
                min-width: 0;
                max-width: none;
            }
        }

        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #003087;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .info-box {
            background: #f9f9f9;
            border-left: 4px solid #003087;
            border-radius: 4px;
            margin-bottom: 20px;
            overflow: hidden;
        }

        .info-box-header {
            padding: 15px;
            cursor: pointer;
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
        }

        .info-box-header:hover {
            background: #f0f0f0;
        }

        .info-box-toggle {
            transition: transform 0.3s;
            font-size: 1.2rem;
        }

        .info-box-toggle.collapsed {
            transform: rotate(-90deg);
        }

        .info-box-content {
            max-height: 500px;
            padding: 0 15px 15px 15px;
            transition: max-height 0.3s ease, padding 0.3s ease;
            overflow: hidden;
        }

        .info-box-content.collapsed {
            max-height: 0;
            padding: 0 15px;
        }

        .info-box-content p {
            color: #666;
            line-height: 1.6;
        }

        .user-info {
            display: none;
            background: #e8f5e9;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid #a5d6a7;
        }

        .user-info {
            display: none;
            padding: 15px;
            background: #e8f5e9;
            border: 1px solid #a5d6a7;
            border-radius: 4px;
            margin-bottom: 20px;
        }

        .user-info.show {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .user-details {
            display: flex;
            align-items: center;
            gap: 10px;
            color: #1b5e20;
            font-weight: 500;
        }

        .signout-btn {
            padding: 8px 16px;
            background: white;
            color: #2e7d32;
            border: 1px solid #2e7d32;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            transition: all 0.3s;
        }

        .signout-btn:hover {
            background: #2e7d32;
            color: white;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #f5f5f5;
            border-radius: 4px;
            margin-top: 10px;
            overflow: hidden;
            display: none;
            border: 1px solid #e0e0e0;
        }

        .progress-bar.show {
            display: block;
        }

        .progress-fill {
            height: 100%;
            background: #003087;
            width: 0%;
            transition: width 0.3s;
        }

        .download-btn {
            padding: 12px 24px;
            background: #1b5e20;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: all 0.3s;
        }

        @media (max-width: 768px) {
            .download-btn {
                width: 90% !important;
            }

            .container {
                width: 95%;
            }

            .content {
                padding: 20px;
            }

            .teams-grid {
                grid-template-columns: 1fr;
            }

            .manage-btn-container {
                width: 90% !important;
            }

            .header h1 {
                font-size: 1.5rem;
            }

            .section-title {
                font-size: 1.1rem;
            }
        }

        .download-btn:hover:not(:disabled) {
            background: #2e7d32;
            box-shadow: 0 2px 8px rgba(27, 94, 32, 0.3);
        }

        .download-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .manage-btn {
            transition: all 0.3s;
            font-weight: 600;
        }

        .manage-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .manage-btn:not(:disabled):hover {
            opacity: 0.9;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }
    </style>
</head>
<body>
    <!-- Toast Notification Container -->
    <div class="toast-container" id="toastContainer"></div>

    <div class="container">
        <div class="header">
            <h1>AFL Fixture to Calendar</h1>
        </div>

        <div class="content">
            <div class="info-box">
                <div class="info-box-header" onclick="toggleQuickStart()">
                    <span><strong>Quick Start</strong></span>
                    <span class="info-box-toggle collapsed">‚ñº</span>
                </div>
                <div class="info-box-content collapsed" id="quickStartContent">
                    <p>Select your favourite teams below, then use "Download ICS File" to get a calendar file you can import into Google Calendar, Apple Calendar, Outlook, or any calendar app. No sign-in required. Or sign in to Google and import the event automatically.</p>
                </div>
            </div>

            <div class="section">
                
                <div class="user-info" id="userInfo">
                    <div class="user-details">
                        <span>‚úì Signed in as <strong id="userEmail"></strong></span>
                    </div>
                    <button class="signout-btn" id="signoutBtn">Sign Out</button>
                </div>

                <div class="auth-section" id="authSection">
                    <button class="auth-btn" id="authorizeBtn">
                        <svg width="24" height="24" viewBox="0 0 24 24">
                            <path fill="currentColor" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                            <path fill="currentColor" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
                            <path fill="currentColor" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
                            <path fill="currentColor" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
                        </svg>
                        Sign in with Google
                    </button>
                </div>
            </div>

            <div class="section">
                <div class="section-title">2026 AFL Season</div>
                <p style="color: #666; margin-bottom: 20px;">Select your favourite teams to add their fixtures to your calendar</p>
            </div>

            <div class="section">
                <div class="section-title">Select Teams</div>
                <div class="teams-grid" id="teamsContainer">
                    <div class="status loading">
                        <div class="spinner"></div>
                        Loading teams...
                    </div>
                </div>
            </div>

            <div class="section">
                <div style="margin-bottom: 20px;">
                    <label style="display: flex; align-items: center; gap: 10px; color: #666; cursor: pointer;">
                        <input type="checkbox" id="allDayEventsCheckbox" style="width: 18px; height: 18px; cursor: pointer; accent-color: #003087;">
                        <span>Create as all-day events (better for year view)</span>
                    </label>
                </div>

                <button class="generate-btn" id="generateBtn" disabled>Add to Google Calendar</button>

                <div class="manage-btn-container">
                    <button class="manage-btn" id="updateBtn" disabled style="background: #2196F3;">Update Existing Events</button>
                    <button class="manage-btn" id="removeBtn" disabled style="background: #f44336;">Remove Selected Team Events</button>
                    <button class="manage-btn" id="removeAllBtn" disabled style="background: #d32f2f; font-weight: 700;">Remove All AFL Events</button>
                </div>

                <div class="progress-bar" id="progressBar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
            </div>

            <div class="section">
                <div class="section-title" style="text-align: center;">üì• Download Calendar File</div>
                <button class="download-btn" id="downloadBtn" style="width: 50%; margin: 0 auto; display: block; padding: 16px; font-size: 1.1rem; font-weight: 600;">Download ICS File</button>
                <p style="text-align: center; color: #666; margin-top: 10px; font-size: 0.9rem;">Works with Google Calendar, Apple Calendar, Outlook, and more</p>
            </div>
        </div>
    </div>

    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <script>
        const API_BASE = 'https://api.squiggle.com.au';
        const CLIENT_ID = '1017993533846-vddmd49lpivato6chlv2kk7nol2u3srf.apps.googleusercontent.com';
        const SCOPES = 'https://www.googleapis.com/auth/calendar.events https://www.googleapis.com/auth/userinfo.email https://www.googleapis.com/auth/userinfo.profile';
        const CURRENT_YEAR = 2026;
        
        let teams = [];
        let ladder = {};
        let tokenClient;
        let accessToken = null;
        let isAddingEvents = false; // Flag to prevent concurrent add operations
        
        // Storage for tracking calendar event IDs
        const EVENT_ID_STORAGE_KEY = 'afl_calendar_event_ids';
        
        // Get stored event IDs mapping (AFL game ID -> Google Calendar event ID)
        function getStoredEventIds() {
            const stored = localStorage.getItem(EVENT_ID_STORAGE_KEY);
            return stored ? JSON.parse(stored) : {};
        }
        
        // Save event IDs mapping
        function saveEventIds(eventIds) {
            localStorage.setItem(EVENT_ID_STORAGE_KEY, JSON.stringify(eventIds));
        }
        
        // Generate unique ID for AFL game
        function generateAflEventId(game, year) {
            // Create a unique ID based on game details
            // Format: afl-YEAR-GAMEID or afl-YEAR-ROUND-HOME-AWAY
            if (game.id) {
                return `afl-${year}-${game.id}`;
            }
            const round = game.round || 'unknown';
            const home = (game.hteam || 'unknown').replace(/\s+/g, '-').toLowerCase();
            const away = (game.ateam || 'unknown').replace(/\s+/g, '-').toLowerCase();
            return `afl-${year}-r${round}-${home}-vs-${away}`;
        }
        
        // Store calendar event ID
        function storeEventId(aflEventId, googleCalendarEventId, gameDetails) {
            const eventIds = getStoredEventIds();
            eventIds[aflEventId] = {
                calendarEventId: googleCalendarEventId,
                timestamp: Date.now(),
                gameDetails: gameDetails // Store game info for reference
            };
            saveEventIds(eventIds);
        }
        
        // Get calendar event ID for an AFL game
        function getCalendarEventId(aflEventId) {
            const eventIds = getStoredEventIds();
            return eventIds[aflEventId]?.calendarEventId;
        }
        
        // Remove event ID from storage
        function removeStoredEventId(aflEventId) {
            const eventIds = getStoredEventIds();
            delete eventIds[aflEventId];
            saveEventIds(eventIds);
        }
        
        // Clear all stored event IDs for a specific year
        function clearEventIdsForYear(year) {
            const eventIds = getStoredEventIds();
            const prefix = `afl-${year}-`;
            const updatedIds = {};
            
            for (const [key, value] of Object.entries(eventIds)) {
                if (!key.startsWith(prefix)) {
                    updatedIds[key] = value;
                }
            }
            
            saveEventIds(updatedIds);
        }
        
        // Get all stored events for a specific year
        function getStoredEventsForYear(year) {
            const eventIds = getStoredEventIds();
            const prefix = `afl-${year}-`;
            const yearEvents = {};
            
            for (const [key, value] of Object.entries(eventIds)) {
                if (key.startsWith(prefix)) {
                    yearEvents[key] = value;
                }
            }
            
            return yearEvents;
        }

        // Toggle Quick Start panel
        function toggleQuickStart() {
            const content = document.getElementById('quickStartContent');
            const toggle = document.querySelector('.info-box-toggle');
            
            content.classList.toggle('collapsed');
            toggle.classList.toggle('collapsed');
        }

        // Initialize Google Identity Services
        function initializeGoogleAuth() {
            try {
                tokenClient = google.accounts.oauth2.initTokenClient({
                    client_id: CLIENT_ID,
                    scope: SCOPES,
                    callback: handleAuthCallback,
                });
            } catch (error) {
                console.error('Failed to initialize Google Auth:', error);
            }
        }

        function handleAuthCallback(response) {
            if (response.error !== undefined) {
                showStatus('error', 'Authorization failed: ' + response.error);
                return;
            }
            
            accessToken = response.access_token;
            
            // Store token expiry time (tokens typically last 1 hour)
            const expiryTime = Date.now() + (response.expires_in * 1000);
            sessionStorage.setItem('google_access_token', accessToken);
            sessionStorage.setItem('google_token_expiry', expiryTime.toString());
            
            document.getElementById('authorizeBtn').style.display = 'none';
            document.getElementById('authSection').style.display = 'none';
            document.getElementById('generateBtn').disabled = false;
            document.getElementById('updateBtn').disabled = false;
            document.getElementById('removeBtn').disabled = false;
            document.getElementById('removeAllBtn').disabled = false;
            
            // Get user info
            getUserInfo();
        }

        async function getUserInfo() {
            try {
                const response = await fetch('https://www.googleapis.com/oauth2/v3/userinfo', {
                    headers: {
                        'Authorization': `Bearer ${accessToken}`
                    }
                });
                
                if (!response.ok) {
                    console.error('Failed to get user info, status:', response.status);
                    throw new Error('Failed to get user info');
                }
                
                const data = await response.json();
                console.log('User data received:', data);
                const displayEmail = data.email || 'Signed In User';
                
                // Store user info in session
                sessionStorage.setItem('google_user_name', displayEmail);
                
                document.getElementById('userEmail').textContent = displayEmail;
                document.getElementById('userInfo').classList.add('show');
                console.log('User info displayed:', displayEmail);
            } catch (error) {
                console.error('Error getting user info:', error);
                // Still show the user info box even if we can't get details
                document.getElementById('userEmail').textContent = 'Signed In';
                document.getElementById('userInfo').classList.add('show');
            }
        }

        document.getElementById('authorizeBtn').addEventListener('click', () => {
            if (!tokenClient) {
                initializeGoogleAuth();
                setTimeout(() => {
                    if (tokenClient) {
                        tokenClient.requestAccessToken({ prompt: 'consent' });
                    }
                }, 100);
            } else {
                tokenClient.requestAccessToken({ prompt: 'consent' });
            }
        });

        document.getElementById('signoutBtn').addEventListener('click', () => {
            if (accessToken) {
                google.accounts.oauth2.revoke(accessToken);
            }
            accessToken = null;
            
            // Clear session storage
            sessionStorage.removeItem('google_access_token');
            sessionStorage.removeItem('google_token_expiry');
            sessionStorage.removeItem('google_user_name');
            
            document.getElementById('authorizeBtn').style.display = 'flex';
            document.getElementById('authSection').style.display = 'block';
            document.getElementById('generateBtn').disabled = true;
            document.getElementById('updateBtn').disabled = true;
            document.getElementById('removeBtn').disabled = true;
            document.getElementById('removeAllBtn').disabled = true;
            document.getElementById('userInfo').classList.remove('show');
        });

        // Load teams on page load
        async function loadTeams() {
            try {
                const response = await fetch(`${API_BASE}/?q=teams`);
                const data = await response.json();
                teams = data.teams;
                
                // Load ladder standings
                await loadLadder();
                
                renderTeams();
            } catch (error) {
                showStatus('error', 'Failed to load teams. Please refresh the page.');
            }
        }

        async function loadLadder() {
            try {
                const response = await fetch(`${API_BASE}/?q=standings;year=${CURRENT_YEAR}`);
                const data = await response.json();
                
                // Create a map of team name to ladder position
                if (data.standings && data.standings.length > 0) {
                    data.standings.forEach(standing => {
                        ladder[standing.name] = {
                            rank: standing.rank,
                            wins: standing.wins,
                            losses: standing.losses,
                            draws: standing.draws,
                            points: standing.pts
                        };
                    });
                }
            } catch (error) {
                console.log('Ladder data not available yet for', CURRENT_YEAR);
            }
        }

        function renderTeams() {
            const container = document.getElementById('teamsContainer');
            container.innerHTML = teams.map(team => {
                // Construct absolute logo URL
                const logoUrl = team.logo.startsWith('http') 
                    ? team.logo 
                    : `https://squiggle.com.au/${team.logo}`;
                
                // Get ladder position if available
                const standing = ladder[team.name];
                const ladderInfo = standing 
                    ? `<span style="color: #4b5563; font-size: 0.85rem; margin-left: auto;">#${standing.rank}</span>`
                    : '';
                
                return `
                    <div class="team-checkbox">
                        <input type="checkbox" id="team-${team.id}" value="${team.id}" data-name="${team.name}">
                        <label for="team-${team.id}" style="display: flex; align-items: center; width: 100%;">
                            <img src="${logoUrl}" alt="${team.name}" class="team-logo" onerror="this.style.display='none'">
                            <span style="flex: 1;">${team.name}</span>
                            ${ladderInfo}
                        </label>
                    </div>
                `;
            }).join('');

            // Add event listeners to checkboxes
            document.querySelectorAll('.team-checkbox input').forEach(cb => {
                cb.addEventListener('change', () => {
                    updateDownloadButtonState();
                });
            });
        }

        function updateDownloadButtonState() {
            // Download button is always enabled
        }

        document.getElementById('generateBtn').addEventListener('click', addToGoogleCalendar);
        document.getElementById('downloadBtn').addEventListener('click', downloadICSFile);
        document.getElementById('updateBtn').addEventListener('click', updateGoogleCalendarEvents);
        document.getElementById('removeBtn').addEventListener('click', removeAllAFLEvents);
        document.getElementById('removeAllBtn').addEventListener('click', removeAllAFLEventsRegardless);

        async function updateGoogleCalendarEvents() {
            if (!accessToken) {
                showStatus('error', 'Please sign in with Google first.');
                return;
            }

            // Validate token is still valid
            if (!isTokenValid()) {
                showStatus('error', 'Your session has expired. Please sign in again.');
                clearSession();
                return;
            }

            const selectedTeams = Array.from(document.querySelectorAll('.team-checkbox input:checked'))
                .map(cb => ({ id: cb.value, name: cb.dataset.name })).filter(t => t.id && t.name);

            if (selectedTeams.length === 0) {
                showStatus('error', 'Please select at least one team.');
                return;
            }

            showStatus('loading', 'Fetching AFL events from your calendar...');
            document.getElementById('updateBtn').disabled = true;

            try {
                // Get existing AFL events
                const existingEvents = await getAFLEventsFromCalendar();
                
                if (existingEvents.length === 0) {
                    showStatus('error', 'No AFL events found in your calendar to update.');
                    document.getElementById('updateBtn').disabled = false;
                    return;
                }

                // Get latest game data
                const games = await fetchGames(CURRENT_YEAR, selectedTeams);
                
                showStatus('loading', `Found ${existingEvents.length} AFL events. Updating with latest data...`);
                document.getElementById('progressBar').classList.add('show');
                
                // Scroll to progress bar
                document.getElementById('progressBar').scrollIntoView({ behavior: 'smooth', block: 'center' });

                let updatedCount = 0;
                let failedCount = 0;
                const processedEventIds = new Set(); // Track which events we've already updated (by event ID not game ID)

                for (let i = 0; i < existingEvents.length; i++) {
                    const event = existingEvents[i];
                    
                    // Skip if we've already processed this specific calendar event
                    if (processedEventIds.has(event.id)) {
                        continue;
                    }
                    
                    // Find matching game by parsing event summary and matching date
                    // Match both "Team A vs Team B" and "Team B vs Team A"
                    const game = games.find(g => {
                        if (!event.summary || !g.date || !g.hteam || !g.ateam) return false;
                        
                        const summaryLower = event.summary.toLowerCase();
                        const hteamLower = g.hteam.toLowerCase();
                        const ateamLower = g.ateam.toLowerCase();
                        
                        // Check if both teams are in the summary (regardless of order)
                        const teamsMatch = summaryLower.includes(hteamLower) && summaryLower.includes(ateamLower);
                        
                        if (!teamsMatch) return false;
                        
                        // Also check if dates match (within same day)
                        if (!event.start) return false;
                        
                        const gameDate = new Date(g.date);
                        let eventDate;
                        
                        if (event.start.dateTime) {
                            eventDate = new Date(event.start.dateTime);
                        } else if (event.start.date) {
                            eventDate = new Date(event.start.date);
                        } else {
                            return false;
                        }
                        
                        // Compare dates (same day)
                        const sameDay = gameDate.getFullYear() === eventDate.getFullYear() &&
                                       gameDate.getMonth() === eventDate.getMonth() &&
                                       gameDate.getDate() === eventDate.getDate();
                        
                        return sameDay;
                    });

                    if (game && game.date) {
                        try {
                            await updateEventInCalendar(event.id, game, CURRENT_YEAR, selectedTeams);
                            processedEventIds.add(event.id); // Mark this event as processed
                            updatedCount++;
                        } catch (error) {
                            console.error('Failed to update event:', event, error);
                            failedCount++;
                        }
                    } else {
                        console.log('No matching game found for event:', event.summary);
                    }

                    const progress = ((i + 1) / existingEvents.length) * 100;
                    document.getElementById('progressFill').style.width = progress + '%';
                    await new Promise(resolve => setTimeout(resolve, 100));
                }

                document.getElementById('progressBar').classList.remove('show');
                document.getElementById('progressFill').style.width = '0%';

                if (updatedCount > 0) {
                    showStatus('success', `‚úì Updated ${updatedCount} events!${failedCount > 0 ? ` (${failedCount} failed)` : ''}`);
                } else {
                    showStatus('error', 'No events were updated.');
                }

                document.getElementById('updateBtn').disabled = false;

            } catch (error) {
                document.getElementById('progressBar').classList.remove('show');
                showStatus('error', 'Failed to update events. Please try again.');
                document.getElementById('updateBtn').disabled = false;
            }
        }

        async function removeAllAFLEvents() {
            if (!accessToken) {
                showStatus('error', 'Please sign in with Google first.');
                return;
            }

            // Validate token is still valid
            if (!isTokenValid()) {
                showStatus('error', 'Your session has expired. Please sign in again.');
                clearSession();
                return;
            }

            const selectedTeams = Array.from(document.querySelectorAll('.team-checkbox input:checked'))
                .map(cb => ({ id: cb.value, name: cb.dataset.name })).filter(t => t.id && t.name);

            if (selectedTeams.length === 0) {
                showStatus('error', 'Please select at least one team.');
                return;
            }

            showStatus('loading', 'Fetching AFL events from your calendar...');
            document.getElementById('removeBtn').disabled = true;

            try {
                const allEvents = await getAFLEventsFromCalendar();
                
                if (allEvents.length === 0) {
                    showStatus('error', 'No AFL events found in your calendar.');
                    document.getElementById('removeBtn').disabled = false;
                    return;
                }

                // Filter events to only include those where the FIRST team is selected
                // The first team in the title is the one the user selected when creating the event
                const selectedTeamNames = selectedTeams
                    .filter(t => t && t.name)
                    .map(t => t.name.toLowerCase());
                const events = allEvents.filter(event => {
                    if (!event.summary) return false;
                    
                    // Split the summary by "vs" to get individual teams
                    const summaryParts = event.summary.split(' vs ');
                    if (summaryParts.length < 2) return false;
                    
                    // Extract the FIRST team name (the user's selected team when event was created)
                    const firstTeam = summaryParts[0].trim().toLowerCase();
                    
                    // Check if the first team matches any selected team
                    return selectedTeamNames.some(selectedTeam => 
                        firstTeam.includes(selectedTeam.replace(/\s/g, '').toLowerCase())
                    );
                });

                if (events.length === 0) {
                    showStatus('error', 'No events found for the selected teams.');
                    document.getElementById('removeBtn').disabled = false;
                    return;
                }

                const skippedCount = allEvents.length - events.length;
                showStatus('loading', `Removing ${events.length} events for selected teams from your calendar...${skippedCount > 0 ? ` (${skippedCount} other AFL events kept)` : ''}`);
                document.getElementById('progressBar').classList.add('show');
                
                // Scroll to progress bar
                document.getElementById('progressBar').scrollIntoView({ behavior: 'smooth', block: 'center' });

                let removedCount = 0;
                let failedCount = 0;

                for (let i = 0; i < events.length; i++) {
                    try {
                        await deleteEventFromCalendar(events[i].id);
                        
                        // Remove the stored event ID mapping
                        const storedEventIds = getStoredEventIds();
                        for (const [aflEventId, data] of Object.entries(storedEventIds)) {
                            if (data.calendarEventId === events[i].id) {
                                removeStoredEventId(aflEventId);
                                break;
                            }
                        }
                        
                        removedCount++;
                    } catch (error) {
                        console.error('Failed to delete event:', events[i], error);
                        failedCount++;
                    }

                    const progress = ((i + 1) / events.length) * 100;
                    document.getElementById('progressFill').style.width = progress + '%';
                    await new Promise(resolve => setTimeout(resolve, 100));
                }

                document.getElementById('progressBar').classList.remove('show');
                document.getElementById('progressFill').style.width = '0%';

                if (removedCount > 0) {
                    showStatus('success', `‚úì Removed ${removedCount} events!${failedCount > 0 ? ` (${failedCount} failed)` : ''}`);
                } else {
                    showStatus('error', 'No events were removed.');
                }

                document.getElementById('removeBtn').disabled = false;

            } catch (error) {
                document.getElementById('progressBar').classList.remove('show');
                showStatus('error', 'Failed to remove events. Please try again.');
                document.getElementById('removeBtn').disabled = false;
            }
        }

        async function removeAllAFLEventsRegardless() {
            if (!accessToken) {
                showStatus('error', 'Please sign in with Google first.');
                return;
            }

            // Validate token is still valid
            if (!isTokenValid()) {
                showStatus('error', 'Your session has expired. Please sign in again.');
                clearSession();
                return;
            }

            // Show confirmation dialog with stronger warning
            const confirmDelete = confirm(
                '‚ö†Ô∏è WARNING: This will delete ALL AFL events from your calendar, regardless of which teams are selected.\n\n' +
                'This action cannot be undone.\n\n' +
                'Are you sure you want to continue?'
            );

            if (!confirmDelete) {
                return;
            }

            showStatus('loading', 'Fetching all AFL events from your calendar...');
            document.getElementById('removeAllBtn').disabled = true;

            try {
                const allEvents = await getAFLEventsFromCalendar();
                
                if (allEvents.length === 0) {
                    showStatus('error', 'No AFL events found in your calendar.');
                    document.getElementById('removeAllBtn').disabled = false;
                    return;
                }

                showStatus('loading', `Removing all ${allEvents.length} AFL events from your calendar...`);
                document.getElementById('progressBar').classList.add('show');
                
                // Scroll to progress bar
                document.getElementById('progressBar').scrollIntoView({ behavior: 'smooth', block: 'center' });

                let removedCount = 0;
                let failedCount = 0;

                for (let i = 0; i < allEvents.length; i++) {
                    try {
                        await deleteEventFromCalendar(allEvents[i].id);
                        
                        // Remove the stored event ID mapping
                        const storedEventIds = getStoredEventIds();
                        for (const [aflEventId, data] of Object.entries(storedEventIds)) {
                            if (data.calendarEventId === allEvents[i].id) {
                                removeStoredEventId(aflEventId);
                                break;
                            }
                        }
                        
                        removedCount++;
                    } catch (error) {
                        console.error('Failed to delete event:', allEvents[i], error);
                        failedCount++;
                    }

                    const progress = ((i + 1) / allEvents.length) * 100;
                    document.getElementById('progressFill').style.width = progress + '%';
                    await new Promise(resolve => setTimeout(resolve, 100));
                }

                document.getElementById('progressBar').classList.remove('show');
                document.getElementById('progressFill').style.width = '0%';

                if (removedCount > 0) {
                    showStatus('success', `‚úì Removed all ${removedCount} AFL events!${failedCount > 0 ? ` (${failedCount} failed)` : ''}`);
                } else {
                    showStatus('error', 'No events were removed.');
                }

                document.getElementById('removeAllBtn').disabled = false;

            } catch (error) {
                document.getElementById('progressBar').classList.remove('show');
                showStatus('error', 'Failed to remove events. Please try again.');
                document.getElementById('removeAllBtn').disabled = false;
            }
        }

        async function getAFLEventsFromCalendar() {
            // Search for events with "vs" in the summary (AFL game format)
            // Search from 2024 onwards to catch events from previous/current/future seasons
            const timeMin = new Date(`2024-01-01T00:00:00Z`).toISOString();
            const timeMax = new Date(`${CURRENT_YEAR + 1}-12-31T23:59:59Z`).toISOString();
            
            const response = await fetch(
                `https://www.googleapis.com/calendar/v3/calendars/primary/events?` +
                `timeMin=${timeMin}&timeMax=${timeMax}&q=vs&maxResults=2500&singleEvents=true`,
                {
                    headers: {
                        'Authorization': `Bearer ${accessToken}`
                    }
                }
            );

            if (!response.ok) {
                throw new Error('Failed to fetch calendar events');
            }

            const data = await response.json();
            // Filter to only AFL events (those with "vs" in summary)
            // Also filter by checking if description contains "AFL" to avoid false positives
            const aflEvents = (data.items || []).filter(event => {
                const hasVs = event.summary && event.summary.includes(' vs ');
                const hasAFL = event.description && event.description.includes('AFL');
                return hasVs && hasAFL;
            });
            
            return aflEvents;
        }

        async function updateEventInCalendar(eventId, game, year, selectedTeams) {
            // Validate game has required fields
            if (!game || !game.date || !game.hteam || !game.ateam) {
                console.error('Invalid game data:', game);
                throw new Error('Game missing required fields (date, hteam, or ateam)');
            }
            
            const gameDate = new Date(game.date);
            const endDate = new Date(gameDate.getTime() + 3 * 60 * 60 * 1000);

            // Use timezone from API if available, otherwise default to AEDT/AEST based on date
            let timezone = game.tz || 'AEDT';
            // Normalize timezone format (API might return +11:00 format)
            if (timezone.includes('+')) {
                const month = gameDate.getMonth();
                const isDST = month >= 9 || month <= 2;
                timezone = isDST ? 'AEDT' : 'AEST';
            }

            // Check if user wants all-day events
            const allDay = document.getElementById('allDayEventsCheckbox').checked;

            // Get ladder positions for teams
            const homeStanding = ladder[game.hteam];
            const awayStanding = ladder[game.ateam];
            const homeRank = homeStanding ? ` (#${homeStanding.rank})` : '';
            const awayRank = awayStanding ? ` (#${awayStanding.rank})` : '';

            // Determine which team to show first (user's selected team)
            const selectedTeamNames = selectedTeams.filter(t => t && t.name).map(t => t.name);
            let firstTeam, secondTeam, firstRank, secondRank;
            
            // Check if home team is selected
            const homeSelected = selectedTeamNames.includes(game.hteam);
            const awaySelected = selectedTeamNames.includes(game.ateam);
            
            // If only one team is selected, show it first
            if (homeSelected && !awaySelected) {
                firstTeam = game.hteam;
                secondTeam = game.ateam;
                firstRank = homeRank;
                secondRank = awayRank;
            } else if (awaySelected && !homeSelected) {
                firstTeam = game.ateam;
                secondTeam = game.hteam;
                firstRank = awayRank;
                secondRank = homeRank;
            } else {
                // Both or neither selected, default to home team first
                firstTeam = game.hteam;
                secondTeam = game.ateam;
                firstRank = homeRank;
                secondRank = awayRank;
            }

            const event = {
                summary: allDay ? `${firstTeam} vs ${secondTeam}` : `${firstTeam} vs ${secondTeam} (${timezone})`,
                location: game.venue || 'TBA',
                description: `AFL ${year} - ${game.round ? `Round ${game.round}` : 'TBA'}\nHome: ${game.hteam}${homeRank}\nAway: ${game.ateam}${awayRank}${game.venue ? `\nVenue: ${game.venue}` : ''}`,
                colorId: '7' // Peacock color for AFL games
            };

            if (allDay) {
                // All-day event (shows in year view)
                const dateStr = gameDate.toISOString().split('T')[0];
                event.start = { date: dateStr };
                event.end = { date: dateStr };
            } else {
                // Timed event
                event.start = {
                    dateTime: gameDate.toISOString(),
                    timeZone: 'Australia/Melbourne'
                };
                event.end = {
                    dateTime: endDate.toISOString(),
                    timeZone: 'Australia/Melbourne'
                };
            }

            const response = await fetch(
                `https://www.googleapis.com/calendar/v3/calendars/primary/events/${eventId}`,
                {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Bearer ${accessToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(event)
                }
            );

            if (!response.ok) {
                throw new Error('Failed to update event');
            }

            const updatedEvent = await response.json();
            
            // Update the stored event ID mapping with latest game details
            const aflEventId = generateAflEventId(game, year);
            const gameDetails = {
                round: game.round,
                homeTeam: game.hteam,
                awayTeam: game.ateam,
                venue: game.venue,
                date: game.date
            };
            storeEventId(aflEventId, updatedEvent.id, gameDetails);
            
            return updatedEvent;
        }

        async function deleteEventFromCalendar(eventId) {
            const response = await fetch(
                `https://www.googleapis.com/calendar/v3/calendars/primary/events/${eventId}`,
                {
                    method: 'DELETE',
                    headers: {
                        'Authorization': `Bearer ${accessToken}`
                    }
                }
            );

            if (!response.ok) {
                throw new Error('Failed to delete event');
            }
        }

        async function addToGoogleCalendar() {
            if (!accessToken) {
                showStatus('error', 'Please sign in with Google first.');
                return;
            }

            // Prevent concurrent add operations
            if (isAddingEvents) {
                showStatus('error', 'Already adding events. Please wait for the current operation to complete.');
                return;
            }

            // Validate token is still valid
            if (!isTokenValid()) {
                showStatus('error', 'Your session has expired. Please sign in again.');
                clearSession();
                return;
            }

            const selectedTeams = Array.from(document.querySelectorAll('.team-checkbox input:checked'))
                .map(cb => ({ id: cb.value, name: cb.dataset.name })).filter(t => t.id && t.name);

            // Debug logging
            console.log(`Selected ${selectedTeams.length} teams out of ${teams.length} total teams`);
            
            if (selectedTeams.length === 0) {
                showStatus('error', 'Please select at least one team.');
                return;
            }

            isAddingEvents = true; // Set flag to prevent concurrent operations
            showStatus('loading', 'Fetching games from Squiggle API...');
            document.getElementById('generateBtn').disabled = true;

            try {
                const games = await fetchGames(CURRENT_YEAR, selectedTeams);

                if (games.length === 0) {
                    showStatus('error', 'No games found for the selected teams and year.');
                    document.getElementById('generateBtn').disabled = !accessToken;
                    isAddingEvents = false; // Clear flag
                    return;
                }

                // Check for existing events to avoid duplicates
                showStatus('loading', 'Checking for existing events...');
                const existingEvents = await getAFLEventsFromCalendar();
                
                // Create a set of existing game identifiers (team names + date)
                // We need to handle that team order might be different in existing events
                const existingGameKeys = new Set();
                existingEvents.forEach(event => {
                    if (event.start && event.summary) {
                        let eventDate;
                        if (event.start.dateTime) {
                            eventDate = new Date(event.start.dateTime);
                        } else if (event.start.date) {
                            eventDate = new Date(event.start.date);
                        }
                        
                        if (eventDate) {
                            const dateKey = `${eventDate.getFullYear()}-${eventDate.getMonth()}-${eventDate.getDate()}`;
                            
                            // Extract both team names from the summary
                            // Summary format is "Team A vs Team B" or "Team A vs Team B (AEDT)"
                            const summaryParts = event.summary.split(' vs ');
                            if (summaryParts.length >= 2) {
                                // Get first team
                                const team1 = summaryParts[0].trim().toLowerCase().replace(/[^a-z]/g, '');
                                // Get second team (remove timezone if present)
                                const team2 = summaryParts[1].replace(/\([^)]*\)/g, '').trim().toLowerCase().replace(/[^a-z]/g, '');
                                
                                // Sort team names alphabetically so order doesn't matter
                                const sortedTeams = [team1, team2].sort().join('');
                                existingGameKeys.add(`${sortedTeams}-${dateKey}`);
                            }
                        }
                    }
                });

                // Filter out games that already exist
                const gamesToAdd = games.filter(game => {
                    if (!game.date || !game.hteam || !game.ateam) return false;
                    
                    const gameDate = new Date(game.date);
                    const dateKey = `${gameDate.getFullYear()}-${gameDate.getMonth()}-${gameDate.getDate()}`;
                    
                    // Normalize team names and sort alphabetically
                    const team1 = game.hteam.toLowerCase().replace(/[^a-z]/g, '');
                    const team2 = game.ateam.toLowerCase().replace(/[^a-z]/g, '');
                    const sortedTeams = [team1, team2].sort().join('');
                    
                    const gameKey = `${sortedTeams}-${dateKey}`;
                    
                    return !existingGameKeys.has(gameKey);
                });

                if (gamesToAdd.length === 0) {
                    showStatus('error', 'All selected games already exist in your calendar. No new events added.');
                    document.getElementById('generateBtn').disabled = !accessToken;
                    isAddingEvents = false; // Clear flag
                    return;
                }

                const skippedCount = games.length - gamesToAdd.length;
                showStatus('loading', `Adding ${gamesToAdd.length} new games to your Google Calendar...${skippedCount > 0 ? ` (${skippedCount} already exist)` : ''}`);
                document.getElementById('progressBar').classList.add('show');
                
                // Scroll to progress bar
                document.getElementById('progressBar').scrollIntoView({ behavior: 'smooth', block: 'center' });

                // Add events to Google Calendar
                let addedCount = 0;
                let failedCount = 0;

                for (let i = 0; i < gamesToAdd.length; i++) {
                    const game = gamesToAdd[i];
                    
                    // Skip games with missing critical data
                    if (!game || !game.date || !game.hteam || !game.ateam) {
                        console.warn('Skipping invalid game:', game);
                        failedCount++;
                        continue;
                    }

                    try {
                        await addEventToCalendar(game, CURRENT_YEAR, selectedTeams);
                        addedCount++;
                    } catch (error) {
                        console.error('Failed to add game:', game, error);
                        failedCount++;
                    }

                    // Update progress
                    const progress = ((i + 1) / gamesToAdd.length) * 100;
                    document.getElementById('progressFill').style.width = progress + '%';

                    // Rate limiting - wait 100ms between requests
                    await new Promise(resolve => setTimeout(resolve, 100));
                }

                document.getElementById('progressBar').classList.remove('show');
                document.getElementById('progressFill').style.width = '0%';

                if (addedCount > 0) {
                    showStatus('success', `‚úì Successfully added ${addedCount} games to your Google Calendar!${failedCount > 0 ? ` (${failedCount} failed)` : ''}`);
                } else {
                    showStatus('error', 'Failed to add games to calendar. Please try again.');
                }

                document.getElementById('generateBtn').disabled = !accessToken;
                isAddingEvents = false; // Clear flag when done

            } catch (error) {
                document.getElementById('progressBar').classList.remove('show');
                console.error('Error in addToGoogleCalendar:', error);
                showStatus('error', `Failed to fetch games: ${error.message}. Please try again.`);
                document.getElementById('generateBtn').disabled = !accessToken;
                isAddingEvents = false; // Clear flag on error
            }
        }

        async function downloadICSFile() {
            const selectedTeams = Array.from(document.querySelectorAll('.team-checkbox input:checked'))
                .map(cb => ({ id: cb.value, name: cb.dataset.name })).filter(t => t.id && t.name);

            if (selectedTeams.length === 0) {
                showStatus('error', 'Please select at least one team.');
                return;
            }

            showStatus('loading', 'Generating ICS file...');

            try {
                const games = await fetchGames(CURRENT_YEAR, selectedTeams);

                if (games.length === 0) {
                    showStatus('error', 'No games found for the selected teams.');
                    return;
                }

                const icsContent = generateICS(games, CURRENT_YEAR, selectedTeams);
                downloadICS(icsContent, `AFL_${CURRENT_YEAR}_Calendar.ics`);

                showStatus('success', `‚úì Downloaded ICS file with ${games.length} games!`);

            } catch (error) {
                showStatus('error', 'Failed to generate ICS file. Please try again.');
            }
        }

        async function fetchGames(year, selectedTeams) {
            try {
                const response = await fetch(`${API_BASE}/?q=games;year=${year}`);
                
                if (!response.ok) {
                    throw new Error(`API returned status ${response.status}`);
                }
                
                const data = await response.json();
                
                if (!data.games || !Array.isArray(data.games)) {
                    throw new Error('Invalid data format from API');
                }
                
                // Filter out games with missing critical data
                let games = data.games.filter(game => {
                    if (!game.hteam || !game.ateam) {
                        console.warn('Skipping game with missing team data:', game);
                        return false;
                    }
                    return true;
                });
                
                console.log(`API returned ${data.games.length} games, ${games.length} valid games after filtering`);
                
                // Only filter by selected teams if not all teams are selected
                if (selectedTeams.length < teams.length && teams.length > 0) {
                    const selectedTeamIds = selectedTeams
                        .filter(t => t && t.id) // Filter out any null/undefined team objects
                        .map(t => parseInt(t.id));
                    games = games.filter(game => 
                        selectedTeamIds.includes(game.hteamid) || selectedTeamIds.includes(game.ateamid)
                    );
                    console.log(`Filtered to ${games.length} games for selected teams`);
                }

                return games;
            } catch (error) {
                console.error('Error fetching games:', error);
                throw error;
            }
        }

        async function addEventToCalendar(game, year, selectedTeams) {
            // Validate game has required fields
            if (!game || !game.date || !game.hteam || !game.ateam) {
                console.error('Invalid game data:', game);
                throw new Error('Game missing required fields (date, hteam, or ateam)');
            }
            
            const gameDate = new Date(game.date);
            const endDate = new Date(gameDate.getTime() + 3 * 60 * 60 * 1000); // 3 hours later

            // Use timezone from API if available, otherwise default to AEDT/AEST based on date
            let timezone = game.tz || 'AEDT';
            // Normalize timezone format (API might return +11:00 format)
            if (timezone.includes('+')) {
                const month = gameDate.getMonth();
                const isDST = month >= 9 || month <= 2;
                timezone = isDST ? 'AEDT' : 'AEST';
            }

            // Check if user wants all-day events
            const allDay = document.getElementById('allDayEventsCheckbox').checked;

            // Get ladder positions for teams
            const homeStanding = ladder[game.hteam];
            const awayStanding = ladder[game.ateam];
            const homeRank = homeStanding ? ` (#${homeStanding.rank})` : '';
            const awayRank = awayStanding ? ` (#${awayStanding.rank})` : '';

            // Determine which team to show first (user's selected team)
            const selectedTeamNames = selectedTeams.filter(t => t && t.name).map(t => t.name);
            let firstTeam, secondTeam, firstRank, secondRank;
            
            // Check if home team is selected
            const homeSelected = selectedTeamNames.includes(game.hteam);
            const awaySelected = selectedTeamNames.includes(game.ateam);
            
            // If only one team is selected, show it first
            if (homeSelected && !awaySelected) {
                firstTeam = game.hteam;
                secondTeam = game.ateam;
                firstRank = homeRank;
                secondRank = awayRank;
            } else if (awaySelected && !homeSelected) {
                firstTeam = game.ateam;
                secondTeam = game.hteam;
                firstRank = awayRank;
                secondRank = homeRank;
            } else {
                // Both or neither selected, default to home team first
                firstTeam = game.hteam;
                secondTeam = game.ateam;
                firstRank = homeRank;
                secondRank = awayRank;
            }

            const event = {
                summary: allDay ? `${firstTeam} vs ${secondTeam}` : `${firstTeam} vs ${secondTeam} (${timezone})`,
                location: game.venue || 'TBA',
                description: `AFL ${year} - ${game.round ? `Round ${game.round}` : 'TBA'}\nHome: ${game.hteam}${homeRank}\nAway: ${game.ateam}${awayRank}${game.venue ? `\nVenue: ${game.venue}` : ''}`,
                colorId: '7' // Peacock color for AFL games
            };

            if (allDay) {
                // All-day event (shows in year view)
                const dateStr = gameDate.toISOString().split('T')[0];
                event.start = { date: dateStr };
                event.end = { date: dateStr };
            } else {
                // Timed event
                event.start = {
                    dateTime: gameDate.toISOString(),
                    timeZone: 'Australia/Melbourne'
                };
                event.end = {
                    dateTime: endDate.toISOString(),
                    timeZone: 'Australia/Melbourne'
                };
            }

            const response = await fetch('https://www.googleapis.com/calendar/v3/calendars/primary/events', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${accessToken}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(event)
            });

            if (!response.ok) {
                throw new Error('Failed to add event');
            }

            const createdEvent = await response.json();
            
            // Generate and store the unique AFL event ID mapping
            const aflEventId = generateAflEventId(game, year);
            const gameDetails = {
                round: game.round,
                homeTeam: game.hteam,
                awayTeam: game.ateam,
                venue: game.venue,
                date: game.date
            };
            storeEventId(aflEventId, createdEvent.id, gameDetails);
            
            return createdEvent;
        }

        function generateICS(games, year, selectedTeams) {
            const now = new Date();
            const timestamp = now.toISOString().replace(/[-:]/g, '').split('.')[0] + 'Z';

            let ics = `BEGIN:VCALENDAR
VERSION:2.0
PRODID:-//AFL Calendar Generator//EN
CALSCALE:GREGORIAN
METHOD:PUBLISH
X-WR-CALNAME:AFL ${year} Season
X-WR-TIMEZONE:Australia/Melbourne
X-WR-CALDESC:AFL ${year} Season Fixtures
`;

            const selectedTeamNames = selectedTeams.filter(t => t && t.name).map(t => t.name);

            games.forEach(game => {
                if (!game.date) return;

                const gameDate = new Date(game.date);
                const dtstart = formatICSDate(gameDate);
                
                // Add 3 hours for game duration (typical AFL game length)
                const endDate = new Date(gameDate.getTime() + 3 * 60 * 60 * 1000);
                const dtend = formatICSDate(endDate);

                // Determine which team to show first (user's selected team)
                let firstTeam, secondTeam;
                
                const homeSelected = selectedTeamNames.includes(game.hteam);
                const awaySelected = selectedTeamNames.includes(game.ateam);
                
                if (homeSelected && !awaySelected) {
                    firstTeam = game.hteam;
                    secondTeam = game.ateam;
                } else if (awaySelected && !homeSelected) {
                    firstTeam = game.ateam;
                    secondTeam = game.hteam;
                } else {
                    // Both or neither selected, default to home team first
                    firstTeam = game.hteam;
                    secondTeam = game.ateam;
                }

                const summary = `${firstTeam} vs ${secondTeam}`;
                const location = game.venue || 'TBA';
                const roundName = game.round ? `Round ${game.round}` : 'TBA';
                
                let description = `AFL ${year} - ${roundName}\\n`;
                description += `Home: ${game.hteam}\\n`;
                description += `Away: ${game.ateam}\\n`;
                if (game.venue) description += `Venue: ${game.venue}\\n`;

                ics += `BEGIN:VEVENT
UID:afl-${game.id}@squiggle.com.au
DTSTAMP:${timestamp}
DTSTART:${dtstart}
DTEND:${dtend}
SUMMARY:${summary}
LOCATION:${location}
DESCRIPTION:${description}
STATUS:CONFIRMED
TRANSP:TRANSPARENT
END:VEVENT
`;
            });

            ics += 'END:VCALENDAR';
            return ics;
        }

        function formatICSDate(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            const seconds = String(date.getSeconds()).padStart(2, '0');
            return `${year}${month}${day}T${hours}${minutes}${seconds}`;
        }

        function downloadICS(content, filename) {
            const blob = new Blob([content], { type: 'text/calendar;charset=utf-8' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(link.href);
        }

        function showStatus(type, message) {
            // Dismiss any existing loading toast before showing new status
            if (type !== 'loading') {
                dismissLoadingToast();
            }
            
            // Convert all messages to toasts
            let title = '';
            let duration = 6000; // Default 6 seconds
            
            if (type === 'error') {
                title = 'Error';
            } else if (type === 'success') {
                title = 'Success';
                duration = 5000; // Success messages auto-dismiss after 5 seconds
            } else if (type === 'loading') {
                title = 'Loading';
                duration = 0; // Loading toasts don't auto-dismiss
            }
            
            showToast(type, title, message, duration);
        }

        // Toast notification system
        let currentLoadingToast = null; // Track the current loading toast

        function showToast(type, title, message, duration = 6000) {
            const container = document.getElementById('toastContainer');
            
            // Remove previous loading toast if a new one is being shown
            if (type === 'loading' && currentLoadingToast) {
                removeToast(currentLoadingToast);
            }
            
            // Create toast element
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            
            // Store reference if it's a loading toast
            if (type === 'loading') {
                currentLoadingToast = toast;
            }
            
            // Icon based on type
            let iconContent = '!';
            if (type === 'error') iconContent = '‚úï';
            if (type === 'success') iconContent = '‚úì';
            if (type === 'loading') iconContent = '<div class="toast-spinner"></div>';
            if (type === 'warning') iconContent = '‚ö†';
            if (type === 'info') iconContent = 'i';
            
            toast.innerHTML = `
                <div class="toast-icon">${iconContent}</div>
                <div class="toast-content">
                    <div class="toast-title">${title}</div>
                    <div class="toast-message">${message}</div>
                </div>
                <button class="toast-close" onclick="removeToast(this.parentElement)">√ó</button>
            `;
            
            container.appendChild(toast);
            
            // Auto-remove after duration (if duration > 0)
            if (duration > 0) {
                setTimeout(() => {
                    removeToast(toast);
                }, duration);
            }
            
            return toast; // Return toast reference for manual removal
        }

        // Convenience function for error toasts
        function showErrorToast(message) {
            showToast('error', 'Error', message);
        }

        // Function to dismiss loading toasts
        function dismissLoadingToast() {
            if (currentLoadingToast) {
                removeToast(currentLoadingToast);
                currentLoadingToast = null;
            }
        }

        function removeToast(toast) {
            if (!toast) return;
            
            // Clear reference if it's the current loading toast
            if (toast === currentLoadingToast) {
                currentLoadingToast = null;
            }
            
            toast.classList.add('removing');
            setTimeout(() => {
                if (toast.parentElement) {
                    toast.parentElement.removeChild(toast);
                }
            }, 300); // Match animation duration
        }

        // Initialize on page load
        window.onload = () => {
            loadTeams();
            // Delay initialization to ensure Google script is loaded
            setTimeout(initializeGoogleAuth, 1000);
            
            // Try to restore previous session
            restoreSession();
        };

        function restoreSession() {
            const storedToken = sessionStorage.getItem('google_access_token');
            const storedExpiry = sessionStorage.getItem('google_token_expiry');
            const storedUserName = sessionStorage.getItem('google_user_name');
            
            // Check if we have a stored token and it hasn't expired
            if (storedToken && storedExpiry) {
                const expiryTime = parseInt(storedExpiry);
                const now = Date.now();
                
                if (now < expiryTime) {
                    // Token is still valid
                    accessToken = storedToken;
                    
                    // Restore UI state
                    document.getElementById('authorizeBtn').style.display = 'none';
                    document.getElementById('authSection').style.display = 'none';
                    document.getElementById('generateBtn').disabled = false;
                    document.getElementById('updateBtn').disabled = false;
                    document.getElementById('removeBtn').disabled = false;
                    document.getElementById('removeAllBtn').disabled = false;
                    
                    // Restore user info if available
                    if (storedUserName) {
                        document.getElementById('userEmail').textContent = storedUserName;
                        document.getElementById('userInfo').classList.add('show');
                    } else {
                        // Try to fetch user info again
                        getUserInfo();
                    }
                    
                    console.log('Session restored successfully');
                } else {
                    // Token expired, clear storage
                    clearSession();
                    console.log('Session expired, please sign in again');
                }
            }
        }

        function isTokenValid() {
            const storedExpiry = sessionStorage.getItem('google_token_expiry');
            if (!storedExpiry) return false;
            
            const expiryTime = parseInt(storedExpiry);
            const now = Date.now();
            
            return now < expiryTime;
        }

        function clearSession() {
            sessionStorage.removeItem('google_access_token');
            sessionStorage.removeItem('google_token_expiry');
            sessionStorage.removeItem('google_user_name');
            accessToken = null;
            
            document.getElementById('authorizeBtn').style.display = 'flex';
            document.getElementById('authSection').style.display = 'block';
            document.getElementById('generateBtn').disabled = true;
            document.getElementById('updateBtn').disabled = true;
            document.getElementById('removeBtn').disabled = true;
            document.getElementById('removeAllBtn').disabled = true;
            document.getElementById('userInfo').classList.remove('show');
        }
        
        // Debugging and utility functions for event ID management
        // These can be called from browser console
        
        // View all stored event IDs
        window.viewStoredEventIds = function() {
            const eventIds = getStoredEventIds();
            console.log('Stored Event IDs:', eventIds);
            console.log('Total events tracked:', Object.keys(eventIds).length);
            return eventIds;
        };
        
        // View stored events for a specific year
        window.viewStoredEventsByYear = function(year) {
            const yearEvents = getStoredEventsForYear(year);
            console.log(`Stored events for ${year}:`, yearEvents);
            console.log(`Total events for ${year}:`, Object.keys(yearEvents).length);
            return yearEvents;
        };
        
        // Clear all stored event IDs for a specific year
        window.clearStoredEventsForYear = function(year) {
            if (confirm(`Are you sure you want to clear all stored event IDs for ${year}?`)) {
                clearEventIdsForYear(year);
                console.log(`Cleared all event IDs for ${year}`);
            }
        };
        
        // Clear all stored event IDs
        window.clearAllStoredEvents = function() {
            if (confirm('Are you sure you want to clear ALL stored event IDs?')) {
                localStorage.removeItem(EVENT_ID_STORAGE_KEY);
                console.log('Cleared all stored event IDs');
            }
        };
        
        // Export stored event IDs as JSON
        window.exportStoredEventIds = function() {
            const eventIds = getStoredEventIds();
            const dataStr = JSON.stringify(eventIds, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `afl-event-ids-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);
        };
        
        // Import stored event IDs from JSON
        window.importStoredEventIds = function(jsonData) {
            try {
                const eventIds = typeof jsonData === 'string' ? JSON.parse(jsonData) : jsonData;
                saveEventIds(eventIds);
                console.log('Successfully imported event IDs:', Object.keys(eventIds).length, 'events');
            } catch (error) {
                console.error('Failed to import event IDs:', error);
            }
        };
        
        console.log('Event ID Management Functions Available:');
        console.log('- viewStoredEventIds() - View all stored event mappings');
        console.log('- viewStoredEventsByYear(year) - View events for a specific year');
        console.log('- clearStoredEventsForYear(year) - Clear events for a specific year');
        console.log('- clearAllStoredEvents() - Clear all stored events');
        console.log('- exportStoredEventIds() - Export to JSON file');
        console.log('- importStoredEventIds(jsonData) - Import from JSON');
    </script>
</body>
</html>