<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>SirusPTB </title>
<script src="https://cdn.jsdelivr.net/npm/chart.js">
document.getElementById("zeroPressureButton").onclick = async () => {
  await sendData('g');
};


// Zero pressure button handler: ensure connection then send 'g'
(function(){
  const zeroBtn = document.getElementById("zeroPressureButton");
  if(!zeroBtn) return;
  zeroBtn.addEventListener('click', async function(e){
    const btn = e.currentTarget;
    // Give immediate feedback
    btn.disabled = true;
    const origText = btn.textContent;
    btn.textContent = "Zeroing...";
    try {
      // If not connected, attempt to connect (this will open the device picker)
      if(!(typeof device !== 'undefined' && device && device.gatt && device.gatt.connected)) {
        try {
          await connectToDevice();
        } catch(connectErr) {
          console.error("Connect failed or cancelled:", connectErr);
          addDataEntry("Zero command cancelled: not connected", "error");
          throw connectErr;
        }
      }
      // Now attempt to send 'g'
      await sendData('g');
      addDataEntry("Zero command sent ('g')", "sent");
    } catch(err) {
      console.error("Zero command error:", err);
      // If sendData already logged an error, this will be additional feedback
      addDataEntry("Zero command failed: " + (err && err.message ? err.message : err), "error");
    } finally {
      btn.disabled = false;
      btn.textContent = origText || "Zero";
    }
  });
})();

</script>
<style>
body {
  margin: 0;
  font-family: Arial, sans-serif;
  background: #121212;
  color: #e0e0e0;
  text-align: center;
}
header {
  padding: 10px;
  font-size: 1.4em;
  font-weight: bold;
}
.canvas-container {
  width: 90%;
  margin: 10px auto;
  height: 300px;
}
canvas {
  width: 100% !important;
  height: 100% !important;
  background: #1e1e1e;
  border-radius: 8px;
}
.button-row {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 10px;
  margin: 10px 0 30px;
}
button {
  padding: 10px 18px;
  border: none;
  border-radius: 8px;
  font-size: 1em;
  cursor: pointer;
  color: white;
  background-color: #333;
}
#loadButton { background-color: #444; }
#connectButton.connecting { background-color: orange; }
#connectButton.connected { background-color: green; }
#connectButton.disconnected { background-color: red; }
#resetButton, #toggleViewButton { background-color: #333; }
#saveButton { background-color: #444; }
#pauseResumeButton.resume { background-color: #CC6600; }

/* Toggle Switch Styles */
.toggle-container {
  display: inline-flex;
  align-items: center;
  gap: 8px;
}

.toggle-switch {
  position: relative;
  width: 60px;
  height: 30px;
  background-color: #555;
  border-radius: 15px;
  cursor: pointer;
  transition: background-color 0.3s;
}

/* Disabled state for toggles */
.toggle-switch.disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

/* Temperature toggle - dull red for both positions */
#tempToggle {
  background-color: #8B3A3A;
}

#tempToggle.active {
  background-color: #8B3A3A;
}

/* Pressure toggle - dull blue for both positions */
#pressureToggle {
  background-color: #4682B4;
}

#pressureToggle.active {
  background-color: #5F9EA0;
}

/* Always on toggle - green when active */
#alwaysOnToggle {
  background-color: #666;
}

#alwaysOnToggle.active {
  background-color: #4CAF50;
}

/* Raw data toggle - purple when active */
#rawDataToggle {
  background-color: #666;
}

#rawDataToggle.active {
  background-color: #8A2BE2;
}

.toggle-slider {
  position: absolute;
  top: 3px;
  left: 3px;
  width: 24px;
  height: 24px;
  background-color: white;
  border-radius: 50%;
  transition: transform 0.3s;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  font-weight: bold;
  color: #333;
}

.toggle-switch.active .toggle-slider {
  transform: translateX(30px);
}

/* Modal styles */
.modal {
  display: none;
  position: fixed;
  z-index: 999;
  left: 0; top: 0; width: 100%; height: 100%;
  background: rgba(0,0,0,0.7);
  justify-content: center; align-items: center;
}
.modal-content {
  background: #1e1e1e;
  padding: 20px;
  border-radius: 10px;
  width: 90%;
  max-width: 400px;
  text-align: center;
}
.modal select {
  width: 80%;
  padding: 8px;
  margin: 10px 0;
  border-radius: 6px;
  background: #333;
  color: #fff;
  border: none;
}
.modal button { margin: 5px; }

/* Settings page */
#settingsPage { display: none; text-align: left; padding: 20px; }
#settingsPage h2 { text-align: center; }
#settingsPage label { display: block; margin: 10px 0 5px; }
#settingsPage input, #settingsPage select { width: 100%; padding: 5px; border-radius: 5px; margin-bottom: 15px; background:#333; color:#fff; border:none; }
#settingsPage button { background-color: #444; margin-top: 20px; }
#settingsPage input:disabled, #settingsPage button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
  background-color: #222;
}
#calibrationValue {
  width: 80px !important; 
  display: inline-block;
  margin-bottom: 0 !important;
  margin-right: 10px;
  padding: 10px 8px;
  height: auto;
  box-sizing: border-box;
}
.calibration-row {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 15px;
}
.calibration-row button {
  height: auto;
  padding: 10px 18px;
  margin: 0;
}

/* Brightness slider styles */
#brightnessSlider {
  -webkit-appearance: none;
  appearance: none;
  height: 8px;
  background: linear-gradient(to right, #333, #666, #999, #ccc);
  border-radius: 4px;
  outline: none;
}

#brightnessSlider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: #4CAF50;
  cursor: pointer;
  border: 2px solid #fff;
  box-shadow: 0 2px 4px rgba(0,0,0,0.3);
}

#brightnessSlider::-moz-range-thumb {
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: #4CAF50;
  cursor: pointer;
  border: 2px solid #fff;
  box-shadow: 0 2px 4px rgba(0,0,0,0.3);
}

#brightnessContainer.disabled {
  opacity: 0.4;
  pointer-events: none;
}

/* Raw data panel styles - Updated for scrolling list */
#rawDataDisplay {
  background: #1e1e1e; 
  color: #00ff00; 
  padding: 10px; 
  margin: 10px auto; 
  width: 90%; 
  border-radius: 8px; 
  font-family: monospace; 
  text-align: left; 
  height: 120px;
  overflow-y: auto;
  transition: all 0.3s ease;
  display: flex;
  flex-direction: column-reverse; /* Newest at the bottom */
}

#rawDataDisplay.hidden {
  display: none;
}

.data-entry {
  margin: 2px 0;
  padding: 2px 5px;
  border-radius: 3px;
  font-size: 0.9em;
  line-height: 1.3;
}

.data-entry.sent {
  color: #ffaa00; /* Orange for sent data */
}

.data-entry.received {
  color: #00ff00; /* Green for received data */
}

.data-entry.error {
  color: #ff0000; /* Red for errors */
}

.data-timestamp {
  color: #888;
  font-size: 0.8em;
  margin-right: 8px;
}

/* Clear data button */
#clearDataButton {
  position: absolute;
  top: 5px;
  right: 5px;
  background: transparent;
  border: none;
  color: #888;
  font-size: 0.8em;
  cursor: pointer;
  padding: 2px 5px;
}

#clearDataButton:hover {
  color: #fff;
}

/* Scrollbar styling for raw data display */
#rawDataDisplay::-webkit-scrollbar {
  width: 8px;
}

#rawDataDisplay::-webkit-scrollbar-track {
  background: #1a1a1a;
  border-radius: 4px;
}

#rawDataDisplay::-webkit-scrollbar-thumb {
  background: #444;
  border-radius: 4px;
}

#rawDataDisplay::-webkit-scrollbar-thumb:hover {
  background: #555;
}

/* Hide number input spinners for calibration and sleep boxes */
#pressureCalibrationInput::-webkit-outer-spin-button,
#pressureCalibrationInput::-webkit-inner-spin-button,
#sleepTimeInput::-webkit-outer-spin-button,
#sleepTimeInput::-webkit-inner-spin-button {
  -webkit-appearance: none;
  margin: 0;
}
#pressureCalibrationInput,
#sleepTimeInput {
  -moz-appearance: textfield;
}


/* Modern Advanced Panel - mobile-first dark theme */
.advanced-panel {
  background: linear-gradient(180deg, #0f1113 0%, #17181a 100%);
  border-radius: 12px;
  padding: 14px;
  box-shadow: 0 8px 24px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.02);
  color: #e6eef6;
  font-size: 14px;
  width: 100%;
  box-sizing: border-box;
}

.adv-row {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 8px;
  width: 100%;
  box-sizing: border-box;
}

.adv-row label {
  flex: 0 0 150px;
  min-width: 110px;
  color: #9aa3ad;
  font-weight: 600;
  font-size: 14px;
}

.adv-controls {
  display: flex;
  gap: 8px;
  align-items: center;
  flex: 1 1 auto;
}

.adv-controls input {
  padding: 10px 12px;
  border-radius: 10px;
  background: #0b0f10;
  border: 1px solid #22282b;
  color: #e6eef6;
  font-size: 16px;
  outline: none;
  min-width: 88px;
  box-sizing: border-box;
}

.adv-controls input::placeholder {
  color: #6b7175;
}

.adv-btn {
  padding: 10px 14px;
  border-radius: 10px;
  background: linear-gradient(180deg, #2b3944 0%, #22313a 100%);
  border: 1px solid rgba(255,255,255,0.03);
  color: #ffffff;
  font-weight: 700;
  font-size: 14px;
  cursor: pointer;
  box-shadow: 0 4px 10px rgba(0,0,0,0.5);
  transition: transform 0.08s ease, box-shadow 0.12s ease;
}

.adv-btn:active {
  transform: translateY(1px) scale(0.997);
  box-shadow: 0 2px 6px rgba(0,0,0,0.6);
}

/* Make inputs appear like standard text fields (no spinner) */
#pressureCalibrationInput::-webkit-outer-spin-button,
#pressureCalibrationInput::-webkit-inner-spin-button,
#sleepTimeInput::-webkit-outer-spin-button,
#sleepTimeInput::-webkit-inner-spin-button {
  -webkit-appearance: none;
  margin: 0;
}
#pressureCalibrationInput,
#sleepTimeInput {
  -moz-appearance: textfield;
}

/* Raw data container tweaks */
.raw-data-container {
  background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
  border-radius: 8px;
  padding: 8px;
  border: 1px solid #202426;
  max-height: 220px;
  overflow: auto;
}

/* Responsive: stack rows on narrow screens */
@media (max-width: 420px) {
  .adv-row {
    flex-direction: column;
    align-items: stretch;
    gap: 6px;
  }
  .adv-row label {
    flex: none;
    min-width: 0;
    text-align: left;
  }
  .adv-controls {
    flex-direction: row;
  }
  .adv-controls input {
    flex: 1 1 auto;
    min-width: 0;
  }
  .adv-btn {
    width: 100%;
  }
}


/* Differentiate button colors */
#setSleepTimeButton,
#setPressureCalibrationButton {
  background: linear-gradient(180deg, #2e7d32 0%, #1b5e20 100%);
  border: 1px solid rgba(0,0,0,0.4);
}

#setSleepTimeButton:active,
#setPressureCalibrationButton:active {
  background: linear-gradient(180deg, #1b5e20 0%, #124d15 100%);
}

#zeroPressureButton {
  background: linear-gradient(180deg, #1565c0 0%, #0d47a1 100%);
  border: 1px solid rgba(0,0,0,0.4);
}

#zeroPressureButton:active {
  background: linear-gradient(180deg, #0d47a1 0%, #093170 100%);
}


/* Equalize buttons and inputs sizes (use a CSS variable for easy tuning) */
:root { --adv-control-width: 96px; }

.adv-btn {
  height: 44px;
  min-width: var(--adv-control-width);
  padding: 0 16px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  box-sizing: border-box;
}

/* Ensure zero button shares same size via class (it already has adv-btn) */
#zeroPressureButton.adv-btn {}

/* Make set buttons explicitly inherit adv-btn style (IDs already styled for color) */
#setSleepTimeButton.adv-btn, #setPressureCalibrationButton.adv-btn {}

/* Inputs: same width/height as buttons for visual balance */
.adv-controls input {
  height: 44px;
  min-width: var(--adv-control-width);
  max-width: 120px;
  flex: 0 0 var(--adv-control-width);
  box-sizing: border-box;
  padding: 10px 12px;
}

/* On small screens, make them stack but remain the same width (full width for easier tapping) */
@media (max-width: 420px) {
  :root { --adv-control-width: 100%; }
  .adv-row { gap: 6px; }
  .adv-controls {
    flex-direction: row;
    gap: 8px;
    align-items: center;
  }
  .adv-controls input {
    flex: 1 1 auto;
    min-width: 0;
    width: 100%;
  }
  .adv-btn {
    width: 100%;
    min-width: 0;
  }
}


/* Disabled button styling for adv-btn */
.adv-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  box-shadow: none;
  transform: none;
  filter: grayscale(10%);
}


/* --- Brightness slider responsive overrides --- */
#brightnessControls { flex: 1 1 auto; min-width: 0; }
#brightnessControls input[type="range"]#brightnessSlider {
  -webkit-appearance: none;
  appearance: none;
  height: 8px;
  width: 100%;
  flex: 1 1 auto;
  min-width: 0;
  margin: 0;
  background: linear-gradient(to right, #333, #666, #999, #ccc);
  border-radius: 4px;
  outline: none;
}
#brightnessControls input[type="range"]#brightnessSlider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: #4CAF50;
  cursor: pointer;
  border: 2px solid #fff;
  box-shadow: 0 2px 4px rgba(0,0,0,0.3);
}
#brightnessControls input[type="range"]#brightnessSlider::-moz-range-thumb {
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: #4CAF50;
  cursor: pointer;
  border: 2px solid #fff;
  box-shadow: 0 2px 4px rgba(0,0,0,0.3);
}
#brightnessValue {
  flex: 0 0 56px;
  text-align: right;
  min-width: 40px;
  margin-left: 8px;
  color: #e0e0e0;
  font-weight: bold;
}
@media (max-width: 420px) {
  #brightnessValue { flex: 0 0 48px; }
  #brightnessControls { gap: 8px; }
}
/* Ensure the general .adv-controls input rules don't force a fixed size on the brightness slider */
.adv-controls input[type="range"] { flex: 1 1 auto !important; min-width: 0 !important; width: 100% !important; }


/* --- Strong overrides to maximize brightness slider width --- */
/* Reduce label width for brightness row so slider gets more room */
.adv-row label[for="brightnessSlider"] {
  flex: 0 0 110px;
  min-width: 90px;
  max-width: 120px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

/* Make the brightness controls use full available space */
#brightnessControls {
  display: flex;
  align-items: center;
  gap: 8px !important;
  flex: 1 1 auto;
  min-width: 0;
}

/* Force the range input to take up as much space as possible */
#brightnessControls input[type="range"]#brightnessSlider {
  -webkit-appearance: none;
  appearance: none;
  flex: 1 1 0%;
  width: auto !important;
  min-width: 0 !important;
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

/* Slightly shrink the numeric value to free space for the slider */
#brightnessValue {
  flex: 0 0 36px !important;
  width: 36px !important;
  min-width: 32px !important;
  max-width: 56px !important;
  text-align: right;
  margin-left: 8px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

/* Extra override to negate other .adv-controls sizing rules */
.adv-controls input[type="range"] {
  flex: 1 1 0% !important;
  width: auto !important;
  min-width: 0 !important;
}

/* Media tweaks for small screens */
@media (max-width: 420px) {
  .adv-row label[for="brightnessSlider"] {
    flex: 0 0 90px;
    min-width: 60px;
  }
  #brightnessValue {
    flex: 0 0 30px !important;
    width: 30px !important;
  }
  #brightnessControls { gap: 6px !important; }
}


/* --- Minimalistic Advanced Panel --- */
.advanced-panel {
  background: #181818;
  border-radius: 8px;
  padding: 12px;
  color: #e0e0e0;
  font-size: 14px;
  width: 100%;
  box-sizing: border-box;
  border: 1px solid #2a2a2a;
}

.adv-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
  width: 100%;
  box-sizing: border-box;
}

.adv-row label {
  flex: 0 0 auto;
  min-width: 120px;
  color: #ccc;
  font-size: 13px;
  font-weight: 500;
}

.adv-controls {
  flex: 1;
  display: flex;
  gap: 8px;
  align-items: center;
}

.adv-controls input, .adv-controls button {
  padding: 6px 10px;
  border-radius: 6px;
  background: #222;
  border: 1px solid #333;
  color: #e0e0e0;
  font-size: 13px;
  outline: none;
  box-sizing: border-box;
}

.adv-btn {
  cursor: pointer;
  transition: background 0.2s ease;
}

.adv-btn:hover {
  background: #2e2e2e;
}

.adv-btn:disabled, .adv-controls input:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.raw-data-container {
  background: #111;
  border-radius: 6px;
  border: 1px solid #222;
  padding: 8px;
  max-height: 200px;
  overflow: auto;
  font-family: monospace;
  font-size: 12px;
  color: #9f9;
}

/* Minimal brightness slider */
#brightnessSlider {
  -webkit-appearance: none;
  appearance: none;
  height: 6px;
  background: #333;
  border-radius: 3px;
  flex: 1;
}

#brightnessSlider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: #4caf50;
  cursor: pointer;
}

#brightnessSlider::-moz-range-thumb {
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: #4caf50;
  cursor: pointer;
}

#brightnessValue {
  min-width: 40px;
  text-align: right;
  font-size: 13px;
}


/* --- Left-justified minimal advanced panel overrides --- */
.advanced-panel {
  text-align: left !important;
  padding: 12px 12px 12px 14px !important;
  border-radius: 6px !important;
  background: #141414 !important;
  border: 1px solid #222 !important;
  box-shadow: none !important;
}

/* Rows: label at fixed width on left, controls start immediately to the right */
.adv-row {
  display: flex !important;
  flex-direction: row !important;
  align-items: center !important;
  gap: 10px !important;
  margin-bottom: 10px !important;
  width: 100% !important;
  box-sizing: border-box !important;
  justify-content: flex-start !important;
}

/* Left-aligned labels with a consistent fixed width */
.adv-row label {
  flex: 0 0 140px !important;
  min-width: 100px !important;
  max-width: 160px !important;
  text-align: left !important;
  color: #c8ced1 !important;
  font-weight: 600 !important;
  margin: 0 !important;
  padding: 0 !important;
  display: block !important;
  white-space: nowrap !important;
  overflow: hidden !important;
  text-overflow: ellipsis !important;
}

/* Controls take remaining width and align left */
.adv-controls {
  flex: 1 1 auto !important;
  display: flex !important;
  gap: 8px !important;
  align-items: center !important;
  justify-content: flex-start !important;
  min-width: 0 !important;
}

/* Inputs and buttons should not force the row to center */
.adv-controls input, .adv-controls button {
  width: auto !important;
  min-width: 56px !important;
  padding: 6px 8px !important;
  background: #1b1b1b !important;
  border: 1px solid #272727 !important;
  color: #e6eef6 !important;
  border-radius: 6px !important;
  box-sizing: border-box !important;
}

/* Make the brightness slider expand to the available width of the controls area */
.brightness-row input[type="range"]#brightnessSlider {
  width: 100% !important;
  min-width: 0 !important;
  margin: 0 !important;
  height: 8px !important;
  box-sizing: border-box !important;
  background: linear-gradient(to right, #2a2a2a, #444) !important;
  border-radius: 4px !important;
}

/* Place the brightness value to the right but don't steal width from slider */
.brightness-row > div, .brightness-row > .adv-controls { width: 100%; }
.brightness-row #brightnessValue {
  flex: 0 0 56px !important;
  min-width: 40px !important;
  text-align: right !important;
  color: #d7dfe6 !important;
  font-weight: 700 !important;
  margin-left: 8px !important;
}

/* Raw data container left align and compact */
.raw-data-container {
  text-align: left !important;
  padding: 8px !important;
  border-radius: 6px !important;
  background: #0f0f0f !important;
  border: 1px solid #191919 !important;
}

/* Responsive adjustments: stack label above controls on narrow screens but left aligned */
@media (max-width: 420px) {
  .adv-row { flex-direction: column !important; align-items: stretch !important; gap: 6px !important; }
  .adv-row label { flex: 0 0 auto !important; min-width: 0 !important; }
  .adv-controls { justify-content: flex-start !important; }
  .brightness-row #brightnessValue { text-align: right; margin-left: 0; }
}


/* --- Table-based advanced panel layout --- */
.adv-table { width:100%; border-collapse: collapse; }
.adv-table td { padding: 6px 0; vertical-align: middle; }
.adv-table .label-cell { width: 180px; padding-right: 12px; text-align: left; color: #c8ced1; font-weight: 600; }
.adv-table .control-cell { padding-left: 0; }

.control-input, .control-btn {
  height: 40px;
  min-width: 120px;
  padding: 0 12px;
  border-radius: 6px;
  background: #1b1b1b;
  border: 1px solid #272727;
  color: #e6eef6;
  font-size: 13px;
  box-sizing: border-box;
}

.control-btn { cursor: pointer; display: inline-flex; align-items: center; justify-content: center; }

.control-range {
  -webkit-appearance: none; appearance: none;
  height: 8px;
  background: linear-gradient(to right, #2a2a2a, #444);
  border-radius: 4px;
  flex: 1;
  min-width: 0;
}
.control-range::-webkit-slider-thumb { -webkit-appearance: none; appearance:none; width:16px; height:16px; border-radius:50%; background:#4CAF50; border:2px solid #fff; cursor:pointer; }
.control-range::-moz-range-thumb { width:16px; height:16px; border-radius:50%; background:#4CAF50; border:2px solid #fff; cursor:pointer; }

.brightness-value { min-width: 56px; text-align: right; font-weight:700; color:#e0e0e0; display:inline-block; }

/* Make input and button elements share same visual size */
.adv-table .control-cell input.control-input { width: 160px; margin-right: 8px; }
.adv-table .control-cell button.control-btn { width: 96px; }

/* On very small screens, stack label above controls */
@media (max-width: 420px) {
  .adv-table .label-cell { width: auto; min-width: 0; padding-bottom: 6px; }
  .adv-table tr { display: block; margin-bottom: 8px; }
  .adv-table .control-cell { display: flex; gap: 8px; }
  .adv-table .control-cell input.control-input { width: 100%; }
  .adv-table .control-cell button.control-btn { width: 100%; }
  .brightness-value { min-width: 40px; }
}


/* --- Adjusted input box width --- */
.adv-table .control-cell input.control-input { width: 130px; margin-right: 8px; }
.adv-table .control-cell button.control-btn { width: 96px; }


/* --- Raw data container full width --- */
.raw-data-container {
  width: 100% !important;
  box-sizing: border-box;
}
.adv-table td[colspan="2"] { padding: 0 !important; }


/* Ensure raw data moved out of table spans full width */
.advanced-panel > .raw-data-container.fullwidth {
  width: 100% !important;
  box-sizing: border-box !important;
  padding: 8px !important;
  background: #0f0f0f !important;
  border: 1px solid #191919 !important;
  border-radius: 6px !important;
}


/* --- Pressure toggle override: always blue --- */
#pressureToggle, #pressureToggle.active { background-color: #104E8B !important; }
#pressureToggle .toggle-slider {
  color: #fff !important;
}


/* --- Pressure toggle: styled like temp toggle but blue --- */
#pressureToggle {
  background-color: #1E90FF !important; /* blue track */
  border-radius: 15px !important;
  width: 60px !important;
  height: 30px !important;
  position: relative !important;
  display: inline-block !important;
  box-sizing: border-box !important;
  padding: 3px !important;
  transition: background-color 0.2s ease !important;
}

#pressureToggle .toggle-slider {
  position: absolute !important;
  top: 3px !important;
  left: 3px !important;
  width: 24px !important;
  height: 24px !important;
  background: #ffffff !important; /* white thumb */
  border-radius: 50% !important;
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  color: #000 !important; /* black text inside thumb */
  font-weight: 700 !important;
  font-size: 12px !important;
  transition: transform 0.2s ease !important;
  box-shadow: 0 2px 4px rgba(0,0,0,0.25) !important;
}

/* When active, move the thumb to the right (same movement as temp toggle) */
#pressureToggle.active .toggle-slider {
  transform: translateX(30px) !important;
}

/* Ensure pressure toggle's text inside thumb doesn't get hidden */
#pressureToggle .toggle-slider * { color: inherit !important; }

/* Keep pressure toggle color same when active */
#pressureToggle.active { background-color: #1E90FF !important; }


/* --- Pressure toggle lighter blue --- */
#pressureToggle, #pressureToggle.active { background-color: #104E8B !important; }


/* --- Smaller buttons for pause, combined gauges, and reset --- */
#pauseButton, #combinedGaugesButton, #resetButton {
  padding: 4px 10px !important;
  font-size: 13px !important;
  border-radius: 6px !important;
}


/* --- Minimal footer with coffee bean icon --- */
body { padding-bottom: 56px !important; } /* make room for sticky footer */

.minimal-footer {
  position: fixed;
  left: 0;
  bottom: 0;
  width: 100%;
  background: rgba(20,20,20,0.95);
  border-top: 1px solid #222;
  box-sizing: border-box;
  padding: 8px 12px;
  z-index: 9999;
  display: flex;
  justify-content: center;
  align-items: center;
}

.footer-inner {
  display: flex;
  align-items: center;
  gap: 10px;
  color: #bfc7cc;
  font-size: 13px;
  line-height: 1;
}

.footer-link {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 36px;
  height: 36px;
  border-radius: 8px;
  background: transparent;
  border: 1px solid transparent;
  transition: background 120ms ease, border-color 120ms ease, transform 120ms ease;
  text-decoration: none;
}

.footer-link svg { display:block; width:20px; height:20px; }

.footer-link:hover, .footer-link:focus {
  background: rgba(255,255,255,0.03);
  border-color: rgba(255,255,255,0.06);
  transform: translateY(-1px);
  outline: none;
}

.footer-text { color: #9aa3ad; font-weight: 600; }

.sr-only {
  position: absolute !important;
  width: 1px !important;
  height: 1px !important;
  padding: 0 !important;
  margin: -1px !important;
  overflow: hidden !important;
  clip: rect(0, 0, 0, 0) !important;
  white-space: nowrap !important;
  border: 0 !important;
}


/* Anchor footer: use flex layout so footer sits at bottom of page when content is short */
html, body { height: 100% !important; }
body { display: flex !important; flex-direction: column !important; min-height: 100vh !important; margin: 0 !important; padding: 0 !important; }
#page-wrapper { flex: 1 1 auto !important; display: flex !important; flex-direction: column !important; }

/* Ensure the footer behaves as part of page flow (not fixed) */
.minimal-footer {
  position: static !important;
  left: auto !important;
  right: auto !important;
  bottom: auto !important;
  width: 100% !important;
  z-index: auto !important;
  box-shadow: none !important;
}

/* Remove body bottom padding added previously */
body { padding-bottom: 0 !important; }

/* Small safety: ensure footer is visible above most content */
.minimal-footer { z-index: 9999; }


/* Smaller labels for toggles */
.toggle-container n {
  font-size: 0.85em !important;
}

</style>
</head>
<body>
<div id="page-wrapper">
<header>SirusPTB </header>
<!-- Graphs Page -->
<div id="graphPage">
<div class="button-row">
<button class="disconnected" id="connectButton">Connect</button>
<div class="toggle-container">
<n>°C/°F:</n>
<div class="toggle-switch" id="tempToggle">
<div class="toggle-slider">C</div>
</div>
</div>
<div class="toggle-container">
<n>Bar/PSI:</n>
<div class="toggle-switch" id="pressureToggle"><div class="toggle-slider">Bar</div></div>
</div>
</div>
</div>
<!-- Updated raw data display with clear button -->
<div id="splitView" style="display:flex; flex-direction:column; width:100%; align-items:center;">
<div style="width: 90%; margin: 0 auto;">
<div id="tempCurrentValue" style="background: #121212; color: #ff7f7f; padding: 8px; margin: 5px 0; border-radius: 6px; font-weight: bold; font-size: 1.1em; text-align: center;">Temperature: -- °C</div>
<div class="canvas-container"><canvas id="tempChart"></canvas></div>
</div>
<div style="width: 90%; margin: 0 auto;">
<div id="pressureCurrentValue" style="background: #121212; color: #7fbfff; padding: 8px; margin: 5px 0; border-radius: 6px; font-weight: bold; font-size: 1.1em; text-align: center;">Pressure: -- bar</div>
<div class="canvas-container"><canvas id="pressureChart"></canvas></div>
</div>
</div>
<div id="combinedView" style="display:none; width:100%; align-items:center;">
<div style="width: 90%; margin: 0 auto;">
<div id="combinedCurrentValue" style="background: #121212; color: #e0e0e0; padding: 8px; margin: 5px 0; border-radius: 6px; font-weight: bold; font-size: 1.1em; text-align: center;">
<n style="color: #ff7f7f;">Temperature: -- °C</n> | <n style="color: #7fbfff;">Pressure: -- bar</n>
</div>
<div class="canvas-container"><canvas id="combinedChart"></canvas></div>
</div>
</div>
<div id="gaugeView" style="display:none; width:100%; align-items:center;">
<div style="width: 90%; margin: 0 auto; display: flex; flex-direction: column; gap: 20px;">
<div style="display: flex; justify-content: center; gap: 40px; flex-wrap: wrap;">
<!-- Temperature Gauge -->
<div style="display: flex; flex-direction: column; align-items: center;">
<div style="position: relative; width: 280px; height: 280px;">
<canvas height="280" id="tempGauge" style="border-radius: 50%; background: #121212;" width="280"></canvas>
</div>
</div>
<!-- Pressure Gauge -->
<div style="display: flex; flex-direction: column; align-items: center;">
<div style="position: relative; width: 280px; height: 280px;">
<canvas height="280" id="pressureGauge" style="border-radius: 50%; background: #121212;" width="280"></canvas>
</div>
</div>
</div>
</div>
</div>
<div class="button-row">
<button id="pauseResumeButton">Pause</button>
<button id="toggleViewButton">Toggle View</button>
<button id="toggleGaugeButton">Toggle Gauges</button>
<button id="resetButton">Reset</button>
</div>
<div class="button-row">
<button id="saveButton">Save</button>
<button id="loadButton">Load</button>
<button id="deleteButton">Delete</button>
</div>
<!-- Always On Toggle - Standalone row -->
<div style="width: 80%; margin: 10px auto;">
<div style="padding: 15px; background: #121212; border-radius: 8px; display: flex; align-items: center; justify-content: center;">
<div class="toggle-container">
<n style="color: #e0e0e0; font-weight: bold;">Keep device screen on:</n>
<div class="toggle-switch" id="alwaysOnToggle" style="background-color: #666;">
<div class="toggle-slider">OFF</div>
</div>
</div>
</div>
</div>

</div>
</div>
</div>
<!-- Advance Section -->
<div id="advanceSection" style="width: 80%; margin: 20px auto;">
<button id="advanceToggle" style="width: 100%; padding: 10px; border-radius: 6px; background:#444; color:#fff; font-weight:bold; cursor:pointer; text-align:left;">
    Advance ▼
  </button>


<div id="advanceContent" class="advanced-panel" style="display:none;">
  <table class="adv-table" role="presentation">
    <tbody>
      <tr>
        <td class="label-cell"><label>Zero pressure:</label></td>
        <td class="control-cell"><button id="zeroPressureButton" class="adv-btn control-btn" disabled>Zero</button></td>
      </tr>
      <tr>
        <td class="label-cell"><label for="sleepTimeInput">Device sleep time (min):</label></td>
        <td class="control-cell">
          <input type="number" id="sleepTimeInput" class="control-input" min="1" max="60" value="5" />
          <button id="setSleepTimeButton" class="adv-btn control-btn" disabled>Set</button>
        </td>
      </tr>
      <tr>
        <td class="label-cell"><label for="pressureCalibrationInput">Pressure calibration:</label></td>
        <td class="control-cell">
          <input type="number" id="pressureCalibrationInput" class="control-input" step="0.01" min="-5" max="5" placeholder="0.00" />
          <button id="setPressureCalibrationButton" class="adv-btn control-btn" disabled>Set</button>
        </td>
      </tr>
      <tr>
        <td class="label-cell"><label for="brightnessSlider">Device brightness:</label></td>
        <td class="control-cell" style="display:flex; align-items:center; gap:10px;">
          <input id="brightnessSlider" type="range" min="10" max="250" value="125" class="control-range" />
          <span id="brightnessValue" class="brightness-value">125</span>
        </td>
      </tr>
      <tr>
        <td class="label-cell"><label>Raw Data:</label></td>
        <td class="control-cell">
          <div class="toggle-container" style="display:inline-block;">
            <div class="toggle-switch active" id="rawDataToggle">
              <div class="toggle-slider">ON</div>
            </div>
          </div>
        </td>
      </tr>
      </tbody>
  </table>
  <div class="raw-data-container fullwidth" id="rawDataDisplay" style="height:160px; overflow:auto; margin-top:8px;">
<div class="data-entry">No data yet...
  </div>

</div>

<!-- Modal -->
<div class="modal" id="popupModal">
<div class="modal-content">
<h3>Select Saved Graph</h3>
<select id="modalSelect"></select>
<div>
<button id="confirmButton">Confirm</button>
<button id="cancelButton">Cancel</button>
</div>
</div>
</div>
<script>
// --- BLE Variables ---
const serviceUuid = "0000ffe1-0000-1000-8000-00805f9b34fb";
const characteristicUuid = "0000ffe3-0000-1000-8000-00805f9b34fb";
const writeCharacteristicUuid = "0000ffe2-0000-1000-8000-00805f9b34fb"; // Common write characteristic
let device, characteristic, writeCharacteristic;
let tempChart, pressureChart, combinedChart;
let paused = false;
let currentTemp = 0, currentPressure = 0;
let splitView = true;
let gaugeView = false;
let secondsCounter = 0;
let chartData = { labels: [], temp: [], pressure: [] };
let modalAction = "";
let maxPointsValue = 50;
let currentTempUnit = "C"; // Track current temperature unit
let currentPressureUnit = "Bar"; // Track current pressure unit
let tempToggleActive = false; // Track temperature toggle switch state
let pressureToggleActive = false; // Track pressure toggle switch state
let alwaysOnToggleActive = false; // Track always-on toggle switch state
let rawDataToggleActive = true; // Track raw data toggle switch state (default to visible)
let isConnected = false; // Track connection state
let brightnessDataReceived = false; // Track if we've received brightness data
let alwaysOnDataReceived = false; // Track if we've received always-on data
 // Track if we've received calibration data
let receivedDataCount = 0; // Count received data points to identify the sixth one
 // Store the current calibration value
let dataEntries = []; // Store data entries for the scrolling list
let sleepDataReceived = false;
let calibrationDataReceivedOnce = false;

// Ensure the advance panel is fully visible after expansion (tries to show the whole panel when possible)
function ensureAdvancePanelVisible(element) {
  if(!element) return;
  const rect = element.getBoundingClientRect();
  const vh = window.innerHeight || document.documentElement.clientHeight;
  const margin = 12; // pixels of margin from top/bottom

  // If already fully visible, do nothing
  if (rect.top >= margin && rect.bottom <= vh - margin) return;

  // If the element fits within the viewport, scroll so it has a small top margin
  if (rect.height + (margin * 2) <= vh) {
    const target = window.scrollY + rect.top - margin;
    window.scrollTo({ top: Math.max(0, target), behavior: 'smooth' });
    return;
  }

  // If element is taller than viewport, scroll its top into view with a small margin
  const target = window.scrollY + rect.top - margin;
  window.scrollTo({ top: Math.max(0, target), behavior: 'smooth' });
}


// --- SPA Navigation ---
const graphPage = document.getElementById("graphPage");
const settingsPage = document.getElementById("settingsPage");





// --- Modal ---
const modal = document.getElementById("popupModal");
const modalSelect = document.getElementById("modalSelect");
const confirmButton = document.getElementById("confirmButton");
const cancelButton = document.getElementById("cancelButton");

function showModal(action){
  modalAction = action;
  modalSelect.innerHTML="";
  const saved = Object.keys(localStorage).filter(k=>k.startsWith("graph_"));
  if(saved.length===0){ alert("No saved graphs"); return; }
  saved.forEach(k=>{
    const opt = document.createElement("option");
    opt.value = k; opt.text = k.replace("graph_","");
    modalSelect.add(opt);
  });
  modal.style.display="flex";
}

confirmButton.onclick = () => {
  const key = modalSelect.value;
  if(!key){ modal.style.display="none"; return; }
  if(modalAction==="load"){
    const data = JSON.parse(localStorage.getItem(key));
    if(data){
      chartData = data; secondsCounter=data.labels.length;
      
      // Update temperature chart
      tempChart.data.labels=chartData.labels;
      tempChart.data.datasets[0].data=chartData.temp;
      tempChart.update();
      
      // Update pressure chart
      pressureChart.data.labels=chartData.labels;
      pressureChart.data.datasets[0].data=chartData.pressure;
      pressureChart.update();
      
      // Update combined chart
      combinedChart.data.labels=chartData.labels;
      combinedChart.data.datasets[0].data=chartData.temp;
      combinedChart.data.datasets[1].data=chartData.pressure;
      combinedChart.update();
  
  // Update gauges if in gauge view
  updateGauges();
    }
  } else if(modalAction==="delete"){
    localStorage.removeItem(key);
  }
  modal.style.display="none";
};

cancelButton.onclick = () => { modal.style.display="none"; };

// --- Chart Setup ---
function fixCanvasDPI(canvas) {
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  const ctx = canvas.getContext('2d');
  ctx.setTransform(dpr,0,0,dpr,0,0);
}

const currentValuePlugin = {
  id:'currentValue',
  afterDraw(chart){
    // Plugin disabled - labels are now shown above the graphs
    return;
  }
};

function initCharts(){
  const ctxTemp = document.getElementById("tempChart").getContext("2d");
  fixCanvasDPI(ctxTemp.canvas);
  tempChart = new Chart(ctxTemp,{
    type:"line",
    data:{labels:[],datasets:[{label:"Temp",borderColor:"#ff7f7f",data:[],fill:false}]},
    options:{
      responsive:true,
      maintainAspectRatio:true,
      animation:false,
      plugins:{legend:{display:false}},
      scales:{
        x:{display:true,title:{display:true,text:'Time(sec)'},ticks:{color:'#e0e0e0'}},
        y:{display:true,title:{display:true,text:'Temperature (°C)'},ticks:{color:"#ff7f7f"}}
      }
    },
    plugins:[currentValuePlugin]
  });

  const ctxPressure = document.getElementById("pressureChart").getContext("2d");
  fixCanvasDPI(ctxPressure.canvas);
  pressureChart = new Chart(ctxPressure,{
    type:"line",
    data:{labels:[],datasets:[{label:"Pressure",borderColor:"#7fbfff",data:[],fill:false}]},
    options:{
      responsive:true,
      maintainAspectRatio:true,
      animation:false,
      plugins:{legend:{display:false}},
      scales:{
        x:{display:true,title:{display:true,text:'Time(sec)'},ticks:{color:'#e0e0e0'}},
        y:{display:true,title:{display:true,text:'Pressure (bar)'},ticks:{color:"#7fbfff"}}
      }
    },
    plugins:[currentValuePlugin]
  });

  const ctxCombined = document.getElementById("combinedChart").getContext("2d");
  fixCanvasDPI(ctxCombined.canvas);
  combinedChart = new Chart(ctxCombined,{
    type:"line",
    data:{labels:[],datasets:[
      {label:"Temp",borderColor:"#ff7f7f",data:[],fill:false,yAxisID:"y1"},
      {label:"Pressure",borderColor:"#7fbfff",data:[],fill:false,yAxisID:"y2"}
    ]},
    options:{
      responsive:true,
      maintainAspectRatio:true,
      animation:false,
      plugins:{legend:{display:false}},
      scales:{
        x:{display:true,title:{display:true,text:'Time(sec)'},ticks:{color:'#e0e0e0'}},
        y1:{display:true,title:{display:false},ticks:{color:"#ff7f7f"}},
        y2:{display:true,title:{display:false},ticks:{color:"#7fbfff"}}
      }
    },
    plugins:[currentValuePlugin]
  });
}

initCharts();

// --- Ensure pressure y-axis shows one decimal place ---
try {
  if (typeof pressureChart !== 'undefined' && pressureChart && pressureChart.options && pressureChart.options.scales && pressureChart.options.scales.y) {
    pressureChart.options.scales.y.ticks = pressureChart.options.scales.y.ticks || {};
    pressureChart.options.scales.y.ticks.callback = function(value) { return Number(value).toFixed(1); };
    pressureChart.update();
  }
  if (typeof combinedChart !== 'undefined' && combinedChart && combinedChart.options && combinedChart.options.scales && combinedChart.options.scales.y2) {
    combinedChart.options.scales.y2.ticks = combinedChart.options.scales.y2.ticks || {};
    combinedChart.options.scales.y2.ticks.callback = function(value) { return Number(value).toFixed(1); };
    combinedChart.update();
  }
} catch(e) { console.log('Pressure axis formatting error:', e); }


// --- Ensure temperature y-axis shows no decimal places ---
try {
  if (typeof tempChart !== 'undefined' && tempChart && tempChart.options && tempChart.options.scales && tempChart.options.scales.y) {
    tempChart.options.scales.y.ticks = tempChart.options.scales.y.ticks || {};
    tempChart.options.scales.y.ticks.callback = function(value) { return Number(value).toFixed(1); };
    tempChart.update();
  }
  if (typeof combinedChart !== 'undefined' && combinedChart && combinedChart.options && combinedChart.options.scales && combinedChart.options.scales.y1) {
    combinedChart.options.scales.y1.ticks = combinedChart.options.scales.y1.ticks || {};
    combinedChart.options.scales.y1.ticks.callback = function(value) { return Number(value).toFixed(1); };
    combinedChart.update();
  }
} catch(e) { console.log('Temp axis formatting error:', e); }


// --- Gauge Drawing Functions ---
function drawGauge(canvas, value, min, max, unit, color) {
  const ctx = canvas.getContext('2d');
  const centerX = canvas.width / 2;
  const centerY = canvas.height / 2;
  const radius = 100; // Back to 100 from 120
  
  // Clear canvas with page background color
  ctx.fillStyle = '#121212';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Draw outer circle
  ctx.beginPath();
  ctx.arc(centerX, centerY, radius + 15, 0, 2 * Math.PI);
  ctx.strokeStyle = '#333';
  ctx.lineWidth = 4;
  ctx.stroke();
  
  // Draw gauge background arc (270 degrees)
  const startAngle = 0.75 * Math.PI; // Start at 135 degrees
  const endAngle = 2.25 * Math.PI;   // End at 405 degrees (270 degree arc)
  
  ctx.beginPath();
  ctx.arc(centerX, centerY, radius, startAngle, endAngle);
  ctx.strokeStyle = '#2a2a2a';
  ctx.lineWidth = 20;
  ctx.stroke();
  
  // Only draw value arc if connected and value is not placeholder
  if(isConnected && value !== null) {
    // Calculate value angle
    const valueRange = max - min;
    const normalizedValue = Math.max(0, Math.min(1, (value - min) / valueRange));
    const valueAngle = startAngle + normalizedValue * (endAngle - startAngle);
    
    // Draw value arc
    ctx.beginPath();
    ctx.arc(centerX, centerY, radius, startAngle, valueAngle);
    ctx.strokeStyle = color;
    ctx.lineWidth = 20;
    ctx.stroke();
  }
  
  // Draw tick marks and labels
  ctx.strokeStyle = '#666';
  ctx.lineWidth = 2;
  ctx.fillStyle = '#999';
  ctx.font = '14px Arial'; // Back to 14px from 16px
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  
  for(let i = 0; i <= 10; i++) {
    const tickAngle = startAngle + (i / 10) * (endAngle - startAngle);
    const innerRadius = radius - 20;
    const outerRadius = radius + 10;
    const labelRadius = radius + 30; // Back to 30 from 35
    
    // Draw tick mark
    ctx.beginPath();
    ctx.moveTo(
      centerX + Math.cos(tickAngle) * innerRadius,
      centerY + Math.sin(tickAngle) * innerRadius
    );
    ctx.lineTo(
      centerX + Math.cos(tickAngle) * outerRadius,
      centerY + Math.sin(tickAngle) * outerRadius
    );
    ctx.stroke();
    
    // Draw tick value label
    const tickValue = min + (i / 10) * (max - min);
    const labelX = centerX + Math.cos(tickAngle) * labelRadius;
    const labelY = centerY + Math.sin(tickAngle) * labelRadius;
    ctx.fillText(Math.round(tickValue).toString(), labelX, labelY);
  }
  
  // Draw center value
  ctx.fillStyle = color;
  ctx.font = 'bold 28px Arial'; // Back to 28px from 32px
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  
  // Show "--.-" if disconnected or null value, otherwise show the actual value
  if(!isConnected || value === null) {
    ctx.fillText("--.-", centerX, centerY - 15);
  } else {
    ctx.fillText(value.toFixed(1), centerX, centerY - 15);
  }
  
  // Draw unit
  ctx.fillStyle = '#ccc';
  ctx.font = '18px Arial'; // Back to 18px from 20px
  ctx.fillText(unit, centerX, centerY + 15);
}

function updateGauges() {
  if(!gaugeView) return;
  
  // Determine units and values
  const tempUnit = currentTempUnit === "F" ? "°F" : "°C";
  const pressureUnit = currentPressureUnit === "PSI" ? "PSI" : "bar";
  
  let displayTemp = isConnected ? currentTemp : null;
  let displayPressure = isConnected ? currentPressure : null;
  
  // Convert units for gauges if needed
  if (currentTempUnit === "F") {
    displayTemp = displayTemp;
  }
  
  if (currentPressureUnit === "PSI") {
    displayPressure = displayPressure;
  }
  
  // Set gauge ranges according to specifications
  let tempMin, tempMax;
  if(currentTempUnit === "F") {
    tempMin = 0; 
    tempMax = 302; // Fahrenheit: 0°F to 302°F
  } else {
    tempMin = 0; 
    tempMax = 150; // Celsius: 0°C to 150°C
  }
  
  let pressureMin, pressureMax;
  if(currentPressureUnit === "PSI") {
    pressureMin = 0; 
    pressureMax = 262; // PSI: 0 to 262 PSI
  } else {
    pressureMin = 0; 
    pressureMax = 18; // Bar: 0 to 18 bar
  }
  
  // Draw gauges
  const tempCanvas = document.getElementById('tempGauge');
  const pressureCanvas = document.getElementById('pressureGauge');
  
  if(tempCanvas && pressureCanvas) {
    drawGauge(tempCanvas, displayTemp, tempMin, tempMax, tempUnit, '#ff7f7f');
    drawGauge(pressureCanvas, displayPressure, pressureMin, pressureMax, pressureUnit, '#7fbfff');
  }
}

// --- Helper function to update temperature toggle switch ---
function updateTempToggleSwitch(unit) {
  const toggle = document.getElementById("tempToggle");
  const slider = toggle.querySelector(".toggle-slider");
  
  currentTempUnit = unit;
  
  if (unit === "C") {
    toggle.classList.remove("active");
    slider.textContent = "C";
    tempToggleActive = false;
  } else if (unit === "F") {
    toggle.classList.add("active");
    slider.textContent = "F";
    tempToggleActive = true;
  } else {
    // Default to C
    toggle.classList.remove("active");
    slider.textContent = "C";
    tempToggleActive = false;
    currentTempUnit = "C";
  }
}

// --- Helper function to update pressure toggle switch ---
function updatePressureToggleSwitch(unit) {
  const toggle = document.getElementById("pressureToggle");
  const slider = toggle.querySelector(".toggle-slider");
  
  currentPressureUnit = unit;
  
  if (unit === "Bar") {
    toggle.classList.remove("active");
    slider.textContent = "Bar";
    pressureToggleActive = false;
  } else if (unit === "PSI") {
    toggle.classList.add("active");
    slider.textContent = "PSI";
    pressureToggleActive = true;
  } else {
    // Default to Bar
    toggle.classList.remove("active");
    slider.textContent = "Bar";
    pressureToggleActive = false;
    currentPressureUnit = "Bar";
  }
}

// --- Helper function to update always-on toggle switch ---
function updateAlwaysOnToggleSwitch(isOn) {
  const toggle = document.getElementById("alwaysOnToggle");
  const slider = toggle.querySelector(".toggle-slider");
  
  alwaysOnToggleActive = isOn;
  
  if (isOn) {
    toggle.classList.add("active");
    slider.textContent = "ON";
  } else {
    toggle.classList.remove("active");
    slider.textContent = "OFF";
  }
}

// --- Helper function to update raw data toggle switch ---
function updateRawDataToggleSwitch(isVisible) {
  const toggle = document.getElementById("rawDataToggle");
  const slider = toggle.querySelector(".toggle-slider");
  const rawDataDisplay = document.getElementById("rawDataDisplay");
  
  rawDataToggleActive = isVisible;
  
  if (isVisible) {
    toggle.classList.add("active");
    slider.textContent = "ON";
    rawDataDisplay.classList.remove("hidden");
  } else {
    toggle.classList.remove("active");
    slider.textContent = "OFF";
    rawDataDisplay.classList.add("hidden");
  }
}

// --- Helper function to update brightness slider ---
function updateBrightnessSlider(brightnessValue) {
  const slider = document.getElementById("brightnessSlider");
  const valueDisplay = document.getElementById("brightnessValue");
  
  // Ensure brightness value is within valid range (10-250)
  const clampedValue = Math.max(10, Math.min(250, parseInt(brightnessValue)));
  
  slider.value = clampedValue;
  valueDisplay.textContent = clampedValue;
  
  console.log(`Brightness updated from device: ${clampedValue}`);
}

// --- Pressure conversion functions ---
function barToPsi(bar) {
  return bar; // 1 bar = 14.5038 PSI
}

function psiToBar(psi) {
  return psi;
}

// --- Connection Functions ---
async function connectToDevice() {
  const btn = document.getElementById("connectButton");
  try{
    btn.textContent="Connecting..."; btn.className="connecting";
    device = await navigator.bluetooth.requestDevice({filters:[{namePrefix:"SirusPTB"}],optionalServices:[serviceUuid]});
    const server = await device.gatt.connect();
    const service = await server.getPrimaryService(serviceUuid);
    
    // Get the read/notify characteristic
    characteristic = await service.getCharacteristic(characteristicUuid);
    console.log("Read characteristic properties:", characteristic.properties);
    
    // Try to get a separate write characteristic
    try {
      writeCharacteristic = await service.getCharacteristic(writeCharacteristicUuid);
      console.log("Write characteristic found with properties:", writeCharacteristic.properties);
    } catch(e) {
      console.log("Separate write characteristic not found, trying to use read characteristic for writing");
      
      // Check if the read characteristic supports writing
      if (characteristic.properties.write || characteristic.properties.writeWithoutResponse) {
        writeCharacteristic = characteristic;
        console.log("Using read characteristic for writing");
      } else {
        // List all available characteristics
        console.log("Listing all characteristics in service:");
        const characteristics = await service.getCharacteristics();
        for (const char of characteristics) {
          console.log(`Characteristic UUID: ${char.uuid}, Properties:`, char.properties);
          if (char.properties.write || char.properties.writeWithoutResponse) {
            writeCharacteristic = char;
            console.log("Found writable characteristic:", char.uuid);
            break;
          }
        }
      }
    }
    
    await characteristic.startNotifications();
    characteristic.addEventListener("characteristicvaluechanged",handleData);

    btn.textContent="Disconnect"; btn.className="connected";
    isConnected = true; // Set connection state to true
    updateConnectionState(true); // Enable toggles
    btn.onclick = disconnectFromDevice;
    
    // Reset brightness and always-on data tracking on new connection
    brightnessDataReceived = false;
    alwaysOnDataReceived = false;
    calibrationDataReceived = false;
    receivedDataCount = 0;

    // Reset sleep data tracking on new connection
    sleepDataReceived = false;

    currentCalibrationValue = null;
    
    if (writeCharacteristic) {
      console.log("Connected successfully, write characteristic available");
    } else {
      console.log("Connected but no write characteristic found");
    }

    device.addEventListener("gattserverdisconnected", handleDisconnection);
  }catch(e){ 
    console.error("Connection error:", e); 
    handleDisconnection();
  }
}

async function disconnectFromDevice() {
  if(characteristic) {
    try {
      await characteristic.stopNotifications();
    } catch(e) {
      console.log("Error stopping notifications:", e);
    }
  }
  if(device && device.gatt.connected) {
    try {
      await device.gatt.disconnect();
    } catch(e) {
      console.log("Error disconnecting:", e);
    }
  }
  handleDisconnection();
}

function handleDisconnection() {
  const btn = document.getElementById("connectButton");
  btn.textContent="Connect"; 
  btn.className="disconnected";
  isConnected = false; // Set connection state to false
  updateConnectionState(false);


// --- Advance Toggle ---
(function(){
  function setupAdvanceToggle(){
    const btn = document.getElementById("advanceToggle");
    const content = document.getElementById("advanceContent");
    if(!btn || !content) return;
    btn.addEventListener('click', function(){
      if(content.style.display === "none" || content.style.display === ""){
        content.style.display = "block";
        btn.textContent = "Advance ▲";
        // Allow layout to settle then ensure the whole panel is visible
        setTimeout(function(){ ensureAdvancePanelVisible(content); }, 60);
        content.scrollIntoView({ behavior: "smooth", block: "start" });
      } else {
        content.style.display = "none";
        btn.textContent = "Advance ▼";
      }
    });
  }
  // Try to setup after a short delay to ensure DOM elements are present
  setTimeout(setupAdvanceToggle, 50);
})();
 // Disable toggles
  updateGauges(); // Update gauges to show "--.-"
  characteristic = null;
  writeCharacteristic = null;
  device = null;
  btn.onclick = connectToDevice;
  
  // Reset brightness and always-on tracking on disconnection
  brightnessDataReceived = false;
  alwaysOnDataReceived = false;
  calibrationDataReceived = false;
  receivedDataCount = 0;
  currentCalibrationValue = null;
}

// --- Button Setup ---
document.getElementById("connectButton").onclick = connectToDevice;

// --- Send data function ---
async function sendData(command) {
  console.log("Attempting to send:", command);
  console.log("Device:", device);
  console.log("Device connected:", device && device.gatt && device.gatt.connected);
  console.log("Write characteristic:", writeCharacteristic);
  
  if(device && device.gatt && device.gatt.connected && writeCharacteristic) {
    try {
      console.log("Attempting to send data...");
      console.log("Write characteristic properties:", writeCharacteristic.properties);
      
      const encoder = new TextEncoder();
      const data = encoder.encode(command);
      
      // Try writeWithoutResponse first, then regular write
      if (writeCharacteristic.properties.writeWithoutResponse) {
        console.log("Using writeWithoutResponse");
        await writeCharacteristic.writeValueWithoutResponse(data);
      } else if (writeCharacteristic.properties.write) {
        console.log("Using regular write");
        await writeCharacteristic.writeValue(data);
      } else {
        throw new Error("Characteristic doesn't support writing");
      }
      
      console.log("Data sent successfully");
      
      // Add to data entries for scrolling display
      addDataEntry(command, "sent");
      
    } catch(error) {
      console.error("Error sending data:", error);
      addDataEntry(`Error: ${error.message}`, "error");
    }
  } else {
    let errorMsg = "Cannot send data: ";
    if(!device) {
      errorMsg += "No device selected";
    } else if(!device.gatt) {
      errorMsg += "Device GATT not available";
    } else if(!device.gatt.connected) {
      errorMsg += "Device not connected";
    } else if(!writeCharacteristic) {
      errorMsg += "No writable characteristic found - check console for available characteristics";
    }
    
    console.log("Send error:", errorMsg);
    addDataEntry(errorMsg, "error");
  }
}

// --- Helper function to update connection state ---
function updateConnectionState(connected) {
  const tempToggle = document.getElementById("tempToggle");
  const pressureToggle = document.getElementById("pressureToggle");
  const alwaysOnToggle = document.getElementById("alwaysOnToggle");
  const brightnessContainer = document.getElementById("brightnessContainer");
  const zeroBtn = document.getElementById("zeroPressureButton");
  const setSleepBtn = document.getElementById("setSleepTimeButton");
  const setCalBtn = document.getElementById("setPressureCalibrationButton");

  if (connected) {
    if (tempToggle) tempToggle.classList.remove("disabled");
    if (pressureToggle) pressureToggle.classList.remove("disabled");
    if (alwaysOnToggle) alwaysOnToggle.classList.remove("disabled");
    if (brightnessContainer) brightnessContainer.classList.remove("disabled");

    if (zeroBtn) zeroBtn.disabled = false;
    if (setSleepBtn) setSleepBtn.disabled = false;
    if (setCalBtn) setCalBtn.disabled = false;
  } else {
    if (tempToggle) tempToggle.classList.add("disabled");
    if (pressureToggle) pressureToggle.classList.add("disabled");
    if (alwaysOnToggle) alwaysOnToggle.classList.add("disabled");
    if (brightnessContainer) brightnessContainer.classList.add("disabled");

    if (zeroBtn) zeroBtn.disabled = true;
    if (setSleepBtn) setSleepBtn.disabled = true;
    if (setCalBtn) setCalBtn.disabled = true;
  }

}

// --- Add data entry to scrolling list ---
function addDataEntry(data, type) {
  const timestamp = new Date().toLocaleTimeString();
  const entry = {
    timestamp,
    data,
    type
  };
  
  // Add to beginning of array (newest first)
  dataEntries.unshift(entry);
  
  // Limit to 100 entries to prevent performance issues
  if (dataEntries.length > 100) {
    dataEntries.pop();
  }
  
  // Update the display
  updateDataDisplay();
}

// --- Update the data display ---
function updateDataDisplay() {
  const rawDataDisplay = document.getElementById("rawDataDisplay");
  
  // Clear existing content (Clear button removed)
  rawDataDisplay.innerHTML = "";
  
  // Add entries
  dataEntries.forEach(entry => {
    const entryElement = document.createElement("div");
    entryElement.className = `data-entry ${entry.type}`;
    
    const timestampSpan = document.createElement("span");
    timestampSpan.className = "data-timestamp";
    timestampSpan.textContent = `[${entry.timestamp}]`;
    
    const dataSpan = document.createElement("span");
    dataSpan.textContent = entry.data;
    
    entryElement.appendChild(timestampSpan);
    entryElement.appendChild(dataSpan);
    rawDataDisplay.appendChild(entryElement);
  });
  
  // If no data, show placeholder
  if (dataEntries.length === 0) {
    const placeholder = document.createElement("div");
    placeholder.className = "data-entry";
    placeholder.textContent = "No data yet...";
    rawDataDisplay.appendChild(placeholder);
  }
}

// --- Clear data entries removed (no Clear button)

// --- Temperature Toggle Switch Handler ---

// --- Reset charts function ---
function resetCharts() {
  if (tempChart && pressureChart && combinedChart) {
    chartData = { labels: [], temp: [], pressure: [] };
    secondsCounter = 0;

    tempChart.data.labels = [];
    tempChart.data.datasets[0].data = [];
    tempChart.update();

    pressureChart.data.labels = [];
    pressureChart.data.datasets[0].data = [];
    pressureChart.update();

    combinedChart.data.labels = [];
    combinedChart.data.datasets[0].data = [];
    combinedChart.data.datasets[1].data = [];
    combinedChart.update();
  }
}

document.getElementById("tempToggle").onclick = async () => {
  // Check if disabled (not connected)
  if (document.getElementById("tempToggle").classList.contains("disabled")) {
    return; // Do nothing if disabled
  }
  
  console.log("Temperature toggle switch clicked");
  
  // Send the appropriate command based on new state
  const command = tempToggleActive ? "C" : "F";
  
  // Immediately update the toggle switch visual state
  const newUnit = tempToggleActive ? "C" : "F";
  updateTempToggleSwitch(newUnit);
  
  // Reset and update charts with new units
  resetCharts();
  updateCharts();
  updateGauges();
  
  await sendData(command);
};

// --- Brightness Slider Handler ---
let brightnessTimeout = null;
let userInitiatedBrightnessChange = false; // Flag to track user-initiated changes

document.getElementById("brightnessSlider").oninput = function() {
  const value = this.value;
  document.getElementById("brightnessValue").textContent = value;
  userInitiatedBrightnessChange = true; // Mark as user-initiated
};

document.getElementById("brightnessSlider").onchange = function() {
  const value = this.value;
  
  // Only send command if this was a user-initiated change and we're connected
  if (userInitiatedBrightnessChange && isConnected) {
    // Clear existing timeout to prevent multiple rapid sends
    if (brightnessTimeout) {
      clearTimeout(brightnessTimeout);
    }
    
    // Format the value to 3 digits (e.g., 125 -> "125", 10 -> "010")
    const formattedValue = value.padStart(3, '0');
    const command = `L${formattedValue}`;  // L for brightness command
    sendData(command);
  }
  
  // Reset the flag after handling the change
  userInitiatedBrightnessChange = false;
};

// --- Pressure Toggle Switch Handler ---
// --- Pressure Toggle Switch Handler ---
document.getElementById("pressureToggle").onclick = async () => {
  const toggleEl = document.getElementById("pressureToggle");
  // Check if disabled (not connected)
  if (toggleEl.classList.contains("disabled")) {
    return; // Do nothing if disabled
  }

  console.log("Pressure toggle switch clicked");

  // Determine the new state (toggle the boolean)
  const newActive = !pressureToggleActive;
  // Map new state to unit: true => PSI, false => Bar
  const newUnit = newActive ? "PSI" : "Bar";

  // Update UI/internal state
  updatePressureToggleSwitch(newUnit);

  // Reset and update charts with new units
  resetCharts();
  updateCharts();
  updateGauges();

  // Send 'P' for PSI, 'B' for Bar
  const command = newUnit === "PSI" ? "P" : "B";
  await sendData(command);
};

// --- Always-On Toggle Switch Handler ---
document.getElementById("alwaysOnToggle").onclick = async () => {
  // Check if disabled (not connected)
  if (document.getElementById("alwaysOnToggle").classList.contains("disabled")) {
    return; // Do nothing if disabled
  }
  
  console.log("Always-on toggle switch clicked");
  
  // Toggle the state and send appropriate command
  const newState = !alwaysOnToggleActive;
  const command = newState ? "S1" : "S0";
  
  // Immediately update the toggle switch visual state
  updateAlwaysOnToggleSwitch(newState);
  
  await sendData(command);
};

// --- Raw Data Toggle Switch Handler ---
document.getElementById("rawDataToggle").onclick = () => {
  updateRawDataToggleSwitch(!rawDataToggleActive);
};

document.getElementById("pauseResumeButton").onclick=()=>{
  const btn = document.getElementById("pauseResumeButton");
  paused=!paused;
  btn.textContent=paused?"Resume":"Pause";
  
  // Add/remove the resume class for styling
  if(paused) {
    btn.classList.add("resume");
  } else {
    btn.classList.remove("resume");
  }
};

document.getElementById("resetButton").onclick=()=>{
  chartData={labels:[],temp:[],pressure:[]}; secondsCounter=0;
  
  // Reset charts
  [tempChart,pressureChart,combinedChart].forEach(chart=>{
    chart.data.labels=[];
    chart.data.datasets.forEach(ds=>ds.data=[]);
    chart.update();
  });
  
  // Reset current value displays
  const tempUnit = currentTempUnit === "F" ? "°F" : "°C";
  const pressureUnit = currentPressureUnit === "PSI" ? "PSI" : "bar";
  
  document.getElementById("tempCurrentValue").textContent = `Temperature: -- ${tempUnit}`;
  document.getElementById("pressureCurrentValue").textContent = `Pressure: -- ${pressureUnit}`;
  document.getElementById("combinedCurrentValue").innerHTML = `<span style="color: #ff7f7f;">Temperature: -- ${tempUnit}</span> | <span style="color: #7fbfff;">Pressure: -- ${pressureUnit}</span>`;
  
  // Reset gauges
  updateGauges();
};

document.getElementById("toggleViewButton").onclick=()=>{
  if(!gaugeView) {
    splitView=!splitView; 
    localStorage.setItem("viewChoice",splitView?"split":"combined"); 
  }
  updateView();
};

document.getElementById("toggleGaugeButton").onclick=()=>{
  gaugeView=!gaugeView;
  localStorage.setItem("gaugeMode", gaugeView?"true":"false");
  updateView();
  // Update gauges when switching to gauge view
  if(gaugeView) {
    setTimeout(() => {
      updateGauges();
    }, 50);
  }
};

function updateView(){

    // Hide or show Save/Load/Delete buttons depending on view
    document.getElementById("saveButton").style.display = gaugeView ? "none" : "inline-block";
    document.getElementById("loadButton").style.display = gaugeView ? "none" : "inline-block";
    document.getElementById("deleteButton").style.display = gaugeView ? "none" : "inline-block";

  const toggleViewButton = document.getElementById("toggleViewButton");
  
  if(gaugeView) {
    document.getElementById("splitView").style.display="none";
    document.getElementById("combinedView").style.display="none";
    document.getElementById("gaugeView").style.display="flex";
    toggleViewButton.style.display="none"; // Hide the toggle view button
    document.getElementById("toggleGaugeButton").textContent="Charts";
  } else {
    document.getElementById("splitView").style.display=splitView?"flex":"none";
    document.getElementById("combinedView").style.display=splitView?"none":"flex";
    document.getElementById("gaugeView").style.display="none";
    toggleViewButton.style.display="inline-block"; // Show the toggle view button
    toggleViewButton.textContent=splitView?"Combine":"Split";
    document.getElementById("toggleGaugeButton").textContent="Gauges";
  }
}

// Load saved preferences
if(localStorage.getItem("viewChoice")==="combined") splitView=false;
if(localStorage.getItem("gaugeMode")==="true") gaugeView=true;
updateView();

// Initialize gauges with default values (showing "--.-" since not connected)
setTimeout(() => {
  updateGauges();
}, 100);

document.getElementById("saveButton").onclick=()=>{
  const name=prompt("Enter a name for saved graph:"); if(!name) return;
  localStorage.setItem("graph_"+name,JSON.stringify(chartData));
};
document.getElementById("loadButton").onclick=()=>{showModal("load");};
document.getElementById("deleteButton").onclick=()=>{showModal("delete");};

// --- Data Handling ---
function handleData(event){
  const rawData = new TextDecoder().decode(event.target.value).trim();
  
  // Add to data entries for scrolling display
  addDataEntry(rawData, "received");
  
  // Increment received data count
  receivedDataCount++;
  
  // Check for third and fourth values and update UI accordingly
  const dataParts = rawData.split(",");
  let isFahrenheit = false;
  let isPSI = false;
  
  if(dataParts.length >= 3){
    const thirdValue = dataParts[2].trim();
    if(thirdValue === "C"){
      updateTempToggleSwitch("C");
      isFahrenheit = false;
    } else if(thirdValue === "F"){
      updateTempToggleSwitch("F");
      isFahrenheit = true;
    } else {
      updateTempToggleSwitch("C");
      isFahrenheit = false;
    }
  } else {
    updateTempToggleSwitch("C");
    isFahrenheit = false;
  }
  
  if(dataParts.length >= 4){
    const fourthValue = dataParts[3].trim();
    if(fourthValue === "bar"){
      updatePressureToggleSwitch("Bar");
      isPSI = false;
    } else if(fourthValue === "psi"){
      updatePressureToggleSwitch("PSI");
      isPSI = true;
    } else {
      // Don't change toggle state if we get unknown data
      isPSI = (currentPressureUnit === "PSI");
    }
  } else {
    // Don't change toggle state if no data received - keep current state
    isPSI = (currentPressureUnit === "PSI");
  }
  
  // Check for fifth data point (always-on toggle) - only update toggle if we haven't received always-on data yet
  if(dataParts.length >= 5 && !alwaysOnDataReceived) {
    const fifthValue = dataParts[4].trim();
    if(fifthValue === "1") {
      updateAlwaysOnToggleSwitch(true);
      alwaysOnDataReceived = true;
      console.log("Always-on toggle set to ON from device");
    } else if(fifthValue === "0") {
      updateAlwaysOnToggleSwitch(false);
      alwaysOnDataReceived = true;
      console.log("Always-on toggle set to OFF from device");
    }
  }
  
  // Check for sixth data point (brightness) - only update slider if we haven't received brightness data yet
  if(dataParts.length >= 6 && !brightnessDataReceived) {
    const sixthValue = dataParts[5].trim();
    const brightnessValue = parseInt(sixthValue);
    
    // Validate brightness value is a number and within range (10-250)
    if(!isNaN(brightnessValue) && brightnessValue >= 10 && brightnessValue <= 250) {
      updateBrightnessSlider(brightnessValue);
      brightnessDataReceived = true;
      console.log(`Initial brightness set from device: ${brightnessValue}`);
    }
  }
  
  // Also check if this is specifically the 6th data packet received (alternative approach)
  if(receivedDataCount === 6 && dataParts.length >= 1 && !brightnessDataReceived) {
    // If the 6th packet is just a brightness value
    const brightnessValue = parseInt(dataParts[0].trim());
    if(!isNaN(brightnessValue) && brightnessValue >= 10 && brightnessValue <= 250) {
      updateBrightnessSlider(brightnessValue);
      brightnessDataReceived = true;
      console.log(`Initial brightness set from 6th packet: ${brightnessValue}`);
    }
  }
  
  // Check for seventh data point (calibration value) - only update if we haven't received calibration data yet
  if(dataParts.length >= 7 && !calibrationDataReceived) {
    const seventhValue = dataParts[6].trim();
    const calibrationValue = parseFloat(seventhValue);
    
    // Validate calibration value is a number
    if(!isNaN(calibrationValue)) {
      currentCalibrationValue = calibrationValue;
      calibrationDataReceived = true;
      console.log(`Calibration value received from device: ${calibrationValue}`);
      
      // Update calibration input if settings page is currently open
      if(settingsPage.style.display !== "none") {
        document.getElementById("calibrationValue").value = calibrationValue;
      }
    }
  }
  
  // Also check if this is specifically the 7th data packet received (alternative approach for calibration response)
  if(receivedDataCount === 7 && dataParts.length >= 1 && !calibrationDataReceived) {
    // If the 7th packet is just a calibration value
    const calibrationValue = parseFloat(dataParts[0].trim());
    if(!isNaN(calibrationValue)) {
      currentCalibrationValue = calibrationValue;
      calibrationDataReceived = true;
      console.log(`Calibration value received from 7th packet: ${calibrationValue}`);
      
      // Update calibration input if settings page is currently open
      if(settingsPage.style.display !== "none") {
        document.getElementById("calibrationValue").value = calibrationValue;
      }
    }
  }
  
  

  
  // On first connect, use 10th data point as sleep time

  // On first connect, use 7th data point as calibration value
  if(isConnected && !calibrationDataReceivedOnce && dataParts.length >= 7) {
    const seventhValue = dataParts[6].trim();
    const calVal = parseFloat(seventhValue);
    if(!isNaN(calVal) && calVal >= -5 && calVal <= 5) {
      const calInput = document.getElementById("pressureCalibrationInput");
      if (calInput) {
        calInput.value = calVal.toFixed(2);
        calibrationDataReceivedOnce = true;
        console.log(`Calibration value set from device on connect: ${calVal.toFixed(2)}`);
      }
    }
  }

  if(isConnected && !sleepDataReceived && dataParts.length >= 10) {
    const tenthValue = dataParts[9].trim();
    const sleepVal = parseInt(tenthValue);
    if(!isNaN(sleepVal) && sleepVal >= 1 && sleepVal <= 60) {
      const sleepInput = document.getElementById("sleepTimeInput");
      if (sleepInput) {
        sleepInput.value = sleepVal;
        sleepDataReceived = true;
        console.log(`Sleep time set from device on connect: ${sleepVal} min`);
      }
    }
  }

  if(paused) return;
  
  // Parse temperature and pressure values
  if(dataParts.length >= 2) {
    const tempStr = dataParts[0];
    const pressureStr = dataParts[1];
    
    currentTemp = parseFloat(tempStr);
    currentPressure = Math.max(0, parseFloat(pressureStr));
    
    // Update charts and gauges
    updateCharts();
    updateGauges();
  }
}

// --- Update Charts Function ---
function updateCharts() {
  const label = secondsCounter++;
  chartData.labels.push(label);
  chartData.temp.push(currentTemp);
  chartData.pressure.push(currentPressure);

  if(chartData.labels.length > maxPointsValue) {
    chartData.labels.shift(); 
    chartData.temp.shift(); 
    chartData.pressure.shift();
  }

  // Update temperature chart with appropriate unit
  const tempUnit = currentTempUnit === "F" ? "°F" : "°C";
  tempChart.data.labels = chartData.labels; 
  tempChart.data.datasets[0].data = chartData.temp;
  tempChart.data.datasets[0].label = `Temp (${tempUnit})`;
  tempChart.options.scales.y.title.text = `Temperature (${tempUnit})`;
  
  // Update temperature current value label
  let displayTemp = currentTemp;
  if (currentTempUnit === "F") {
    displayTemp = currentTemp;
  }
  document.getElementById("tempCurrentValue").textContent = `Temperature: ${displayTemp.toFixed(1)} ${tempUnit}`;
  
  tempChart.update();

  // Update pressure chart with appropriate unit
  const pressureUnit = currentPressureUnit === "PSI" ? "PSI" : "bar";
  let displayPressure = currentPressure;
  
  if (currentPressureUnit === "PSI") {
    displayPressure = barToPsi(currentPressure);
  }
  
  pressureChart.data.labels = chartData.labels; 
  pressureChart.data.datasets[0].data = chartData.pressure.map(p => {
    return currentPressureUnit === "PSI" ? barToPsi(p) : p;
  });
  pressureChart.data.datasets[0].label = `Pressure (${pressureUnit})`;
  pressureChart.options.scales.y.title.text = `Pressure (${pressureUnit})`;
  
  // Update pressure current value label
  document.getElementById("pressureCurrentValue").textContent = `Pressure: ${displayPressure.toFixed(1)} ${pressureUnit}`;
  
  pressureChart.update();

  // Update combined chart
  combinedChart.data.labels = chartData.labels;
  combinedChart.data.datasets[0].data = chartData.temp.map(t => {
    return currentTempUnit === "F" ? t : t;
  });
  combinedChart.data.datasets[1].data = chartData.pressure.map(p => {
    return currentPressureUnit === "PSI" ? barToPsi(p) : p;
  });
  combinedChart.data.datasets[0].label = `Temp (${tempUnit})`;
  combinedChart.data.datasets[1].label = `Pressure (${pressureUnit})`;
  
  // Update combined current value label
  document.getElementById("combinedCurrentValue").innerHTML = `<span style="color: #ff7f7f;">Temperature: ${displayTemp.toFixed(1)} ${tempUnit}</span> | <span style="color: #7fbfff;">Pressure: ${displayPressure.toFixed(1)} ${pressureUnit}</span>`;
  
  combinedChart.update();
}



// --- Auto-check BLE every second ---
setInterval(()=>{
  const btn=document.getElementById("connectButton");
  if(device){
    if(device.gatt.connected){
      btn.textContent="Disconnect"; btn.className="connected";
      if(!isConnected) {
        isConnected = true;
        updateConnectionState(true);
        updateGauges(); // Update gauges when connection is restored
      }
    } else {
      btn.textContent="Connect"; btn.className="disconnected";
      if(isConnected) {
        isConnected = false;
        updateConnectionState(false);
        updateGauges(); // Update gauges to show "--.-" when disconnected
      }
    }
  }
},1000);

// Initialize toggles and brightness slider as disabled on page load
updateConnectionState(false);

// --- Advance Toggle ---
document.addEventListener("DOMContentLoaded", function(){
  const btn = document.getElementById("advanceToggle");
  const advContent = document.getElementById("advanceContent");
  if(btn && advContent){
    btn.addEventListener("click", function(){
      if(advContent.style.display === "none" || advContent.style.display === ""){
        advContent.style.display = "block";
        btn.textContent = "Advance ▲";
        setTimeout(function(){ ensureAdvancePanelVisible(advContent); }, 60);
      } else {
        advContent.style.display = "none";
        btn.textContent = "Advance ▼";
      }
    });
  }
});


// --- Sleep Time Button Handler ---
document.getElementById("setSleepTimeButton").onclick = async () => {
  const input = document.getElementById("sleepTimeInput");
  let val = parseInt(input.value, 10);
  if (isNaN(val) || val < 1 || val > 60) {
    alert("Please enter a number between 1 and 60.");
    return;
  }
  // Format value to 2 digits (e.g., 5 -> "05")
  const formatted = val.toString().padStart(2, '0');
  const command = `n${formatted}`;
  await sendData(command);
};



// --- Pressure Calibration Button Handler ---
document.getElementById("setPressureCalibrationButton").onclick = async () => {
  const input = document.getElementById("pressureCalibrationInput");
  let val = input.value.trim();
  // Validate format: up to 4 characters, must be numeric with optional decimal
  if(!/^\d(\.\d{1,2})?$/.test(val)) {
    alert("Please enter a valid number like 1.29 (max 4 chars).");
    return;
  }
  // Ensure length <= 4
  if(val.length > 4) {
    alert("Calibration value must be 4 characters or less.");
    return;
  }
  const command = `c${val}`;
  await sendData(command);
};


</script>

<!-- Added script: ensure zero button sends 'g' and attempts connection if needed -->
<script>
(function(){
  async function handleZeroClick(e){
    const btn = document.getElementById("zeroPressureButton");
    if(btn) {
      // Provide immediate feedback
      btn.disabled = true;
      const origText = btn.textContent;
      btn.textContent = "Zeroing...";
      try {
        // If not connected, attempt to connect (this will open the device picker)
        if(!(typeof device !== 'undefined' && device && device.gatt && device.gatt.connected)) {
          try {
            await connectToDevice();
          } catch(connectErr) {
            console.error("Connect failed or cancelled:", connectErr);
            if(typeof addDataEntry === 'function') addDataEntry("Zero command cancelled: not connected", "error");
            throw connectErr;
          }
        }
        // Now attempt to send 'g'
        await sendData('g');
        if(typeof addDataEntry === 'function') addDataEntry("Zero command sent ('g')", "sent");
      } catch(err) {
        console.error("Zero command error:", err);
        if(typeof addDataEntry === 'function') addDataEntry("Zero command failed: " + (err && err.message ? err.message : err), "error");
      } finally {
        if(btn) {
          btn.disabled = false;
          btn.textContent = origText || "Zero";
        }
      }
    }
  }

  // Attach once DOM is ready
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", function(){
      const z = document.getElementById("zeroPressureButton");
      if(z) z.addEventListener("click", handleZeroClick);
    });
  } else {
    const z = document.getElementById("zeroPressureButton");
    if(z) z.addEventListener("click", handleZeroClick);
  }
})();

document.addEventListener("DOMContentLoaded", function(){
  try {
    const zeroBtn = document.getElementById("zeroPressureButton");
    const setSleepBtn = document.getElementById("setSleepTimeButton");
    const setCalBtn = document.getElementById("setPressureCalibrationButton");
    if (zeroBtn) zeroBtn.disabled = true;
    if (setSleepBtn) setSleepBtn.disabled = true;
    if (setCalBtn) setCalBtn.disabled = true;
  } catch(e) { console.log("init button disable error", e); }
});
</script>




<!-- Minimal footer with coffee-bean icon link to game.html -->

</div>
<footer id="pageFooter" class="minimal-footer" role="contentinfo" aria-label="Site footer">
  <div class="footer-inner">
    <a href="game.html" class="footer-link" aria-label="Play Game" title="Play Game">
      <!-- Coffee bean SVG icon -->
      <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" aria-hidden="true" focusable="false">
        <path d="M21.36 11.04c-1.04-3.12-4.08-6.36-8.04-6.36-0.84 0-1.68 0.12-2.46 0.36 0.9 0.54 1.74 1.32 2.46 2.28 1.74 2.4 2.04 5.04 2.16 6.48 0.12 1.44-0.24 3.18-1.38 4.74 2.64-0.72 5.1-3 6.36-7.5 0.42-1.32 0.36-2.22 0.24-2.99z" fill="#6b4f4b"/>
        <path d="M3.24 12.96c1.04 3.12 4.08 6.36 8.04 6.36 0.84 0 1.68-0.12 2.46-0.36-0.9-0.54-1.74-1.32-2.46-2.28-1.74-2.4-2.04-5.04-2.16-6.48-0.12-1.44 0.24-3.18 1.38-4.74-2.64 0.72-5.1 3-6.36 7.5-0.42 1.32-0.36 2.22-0.24 2.99z" fill="#704942"/>
      </svg>
      <span class="sr-only">Play Game</span>
    </a>
    <div class="footer-text">SirusPTB</div>
  </div>
</footer>





<script>
(function(){
  const versionFile = 'version.json';

  function showLabel(text){
    // try a set of likely container ids/classes, fallback to body
    const ids = ['advanceContent','advancedContent','advance-panel','advanced-panel','advanced','advanceContentPanel'];
    let panel = null;
    for (const id of ids) {
      panel = document.getElementById(id);
      if (panel) break;
    }
    if (!panel) {
      panel = document.querySelector('.advance, .advanced, .advanced-panel, #advanced, #advance') || document.body;
    }
    if (!panel) return;
    let label = document.getElementById('versionLabel');
    if (!label){
      label = document.createElement('div');
      label.id = 'versionLabel';
      label.style.cssText = 'font-size:13px;color:#9aa3ad;margin-bottom:8px;padding:6px 8px;border-radius:6px;background:transparent;';
      panel.insertBefore(label, panel.firstChild);
    }
    label.textContent = text;
  }

  async function fetchVersion(){
    try {
      const res = await fetch('./' + versionFile, {cache: 'no-store'});
      if (!res.ok) throw new Error('Network response not ok: ' + res.status);
      const text = await res.text();
      try {
        const json = JSON.parse(text);
        const ver = json.version || json.ver || json.v || json.name || json.filename;
        if (ver) return String(ver);
        for (const k in json) {
          if (typeof json[k] === 'string') return json[k];
        }
        return JSON.stringify(json).slice(0,200);
      } catch(e) {
        return text.trim();
      }
    } catch(e) {
      return null;
    }
  }

  function tryShow(){
    fetchVersion().then(ver => {
      if (ver) {
        showLabel('Latest firmware: ' + ver);
      } else {
        showLabel('Latest firmware: (not found)');
      }
    }).catch(() => {
      showLabel('Latest firmware: (not found)');
    });
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', tryShow);
  } else {
    tryShow();
  }

  const advToggle = document.getElementById('advanceToggle') || document.getElementById('advToggle') || document.querySelector('.advance-toggle');
  if (advToggle) {
    advToggle.addEventListener('click', tryShow);
  }
})();
</script>


<script>
(function(){
  // Semver-like comparison (handles numeric segments and pre-release after '-')
  function normalizeVersion(v) {
    if(!v) return '';
    v = v.trim();
    v = v.replace(/^v/i,''); // strip leading v
    return v;
  }

  function parseVersion(v) {
    v = normalizeVersion(v);
    const parts = v.split('-');
    const main = parts[0].split('.').map(p => {
      const n = parseInt(p,10);
      return isNaN(n) ? p : n;
    });
    const pre = parts.slice(1).join('-') || null;
    return { main, pre };
  }

  // returns -1 if a<b, 0 if equal, 1 if a>b
  function compareSemver(a, b) {
    try {
      if(a === b) return 0;
      const A = parseVersion(a);
      const B = parseVersion(b);
      const len = Math.max(A.main.length, B.main.length);
      for(let i=0;i<len;i++) {
        const aa = (i < A.main.length) ? A.main[i] : 0;
        const bb = (i < B.main.length) ? B.main[i] : 0;
        // numeric compare when both are numbers
        if (typeof aa === 'number' && typeof bb === 'number') {
          if (aa < bb) return -1;
          if (aa > bb) return 1;
        } else {
          const sa = String(aa), sb = String(bb);
          if (sa < sb) return -1;
          if (sa > sb) return 1;
        }
      }
      // main parts equal: handle pre-release (pre-release is lower priority)
      if (A.pre && !B.pre) return -1;
      if (!A.pre && B.pre) return 1;
      if (A.pre && B.pre) {
        if (A.pre === B.pre) return 0;
        return A.pre < B.pre ? -1 : 1;
      }
      return 0;
    } catch(e) {
      console.error('compareSemver error', e);
      return 0;
    }
  }

  async function fetchFirmwareMeta(path) {
    path = path || 'firmware.json';
    // Try fetch first
    try {
      const res = await fetch(path, {cache: 'no-store'});
      if (!res.ok) throw new Error('HTTP ' + res.status);
      const j = await res.json();
      return j;
    } catch (e) {
      // fallback: check for embedded JSON in the page
      try {
        const el = document.getElementById('firmwareMeta');
        if (el) {
          return JSON.parse(el.textContent || el.innerText || '{}');
        }
      } catch (ee) {
        // ignore
      }
      throw e;
    }
  }

  // Replace existing click handler safely by cloning the button
  function attachEnhancedHandler() {
    const btn = document.getElementById('getFirmwareButton');
    const span = document.getElementById('firmwareVersion');
    if (!btn) return;
    const newBtn = btn.cloneNode(true);
    btn.parentNode.replaceChild(newBtn, btn);

    newBtn.addEventListener('click', async function() {
      const origText = newBtn.textContent;
      newBtn.disabled = true;
      newBtn.textContent = 'Requesting...';
      try {
        const ver = await requestFirmwareVersion({timeout:4000, command:'V'}); // uses existing function
        if (span) {
          span.textContent = ver;
          span.classList.remove('update-available','up-to-date','ahead','unknown');
        }

        // Try to load firmware metadata JSON and compare
        let meta = null;
        try {
          meta = await fetchFirmwareMeta();
        } catch (e) {
          console.warn('Failed to fetch firmware metadata:', e);
        }

        if (meta && meta.version) {
          const latest = String(meta.version).trim();
          const cmp = compareSemver(ver, latest);
          if (cmp < 0) {
            // device is older
            if (span) {
              span.classList.add('update-available');
              span.title = `Device: ${ver} — Latest: ${latest}\n${meta.notes ? meta.notes : ''}`;
            }
            if (typeof addDataEntry === 'function') addDataEntry(`Firmware update available: device ${ver} < latest ${latest}`, 'received');
          } else if (cmp === 0) {
            if (span) {
              span.classList.add('up-to-date');
              span.title = `Device: ${ver} — Latest: ${latest}`;
            }
            if (typeof addDataEntry === 'function') addDataEntry(`Firmware up-to-date: ${ver}`, 'received');
          } else {
            if (span) {
              span.classList.add('ahead');
              span.title = `Device: ${ver} — Latest: ${latest}`;
            }
            if (typeof addDataEntry === 'function') addDataEntry(`Device firmware (${ver}) is newer than JSON (${latest})`, 'received');
          }
        } else {
          // no metadata available
          if (span) {
            span.classList.add('unknown');
            span.title = 'No firmware metadata (firmware.json) found';
          }
          if (typeof addDataEntry === 'function') addDataEntry('Could not load firmware metadata to compare versions', 'error');
        }
      } catch (e) {
        console.error('Enhanced firmware request error', e);
        if (typeof addDataEntry === 'function') addDataEntry('Firmware request failed: ' + (e && e.message ? e.message : e), 'error');
        if (span) { span.textContent = '(no response)'; span.classList.add('unknown'); }
      } finally {
        newBtn.disabled = false;
        newBtn.textContent = origText;
      }
    });
  }

  // Add some visual CSS for version states
  function injectCss() {
    const css = `
#firmwareVersion.up-to-date { color: #62c462 !important; font-weight: 700; }
#firmwareVersion.update-available { color: #ffb020 !important; font-weight: 700; }
#firmwareVersion.ahead { color: #00bfff !important; font-weight: 700; }
#firmwareVersion.unknown { color: #c8ced1 !important; font-weight: 700; }
`;
    const s = document.createElement('style');
    s.type = 'text/css';
    s.appendChild(document.createTextNode(css));
    document.head.appendChild(s);
  }

  // Hook into updateConnectionState so button initial enabled/disabled works
  function hookConnectionState() {
    const btn = document.getElementById('getFirmwareButton');
    if (btn && typeof updateConnectionState === 'function') {
      try {
        btn.disabled = !(typeof device !== 'undefined' && device && device.gatt && device.gatt.connected);
      } catch(e){}
    }
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', function(){
      injectCss();
      attachEnhancedHandler();
      hookConnectionState();
    });
  } else {
    injectCss();
    attachEnhancedHandler();
    hookConnectionState();
  }
})();
</script>

</body>
</html>